
#Область Проверка_заполнения_реквизитов_В_основном_для_ОбработкаПроверкиЗаполнения
// БоР : Проверяет заполнение реквизита ТЧ на форме, так же, как при установке "выдавать ошибку" 06.10.2012 20:09:10
Процедура ПроверитьЗаполнениеРеквизитаТЧФормы(ИмяТЧ, ИмяПоля, Форма, Отказ, УсловиеПроверки = "Не ЗначениеЗаполнено(СтрокаТЧ[ИмяПоля])") Экспорт
	
	РеквизитыФормы = Форма.ПолучитьРеквизиты();
	Для каждого РеквизитФормы Из РеквизитыФормы Цикл
		Если РеквизитФормы.Имя = ИмяТЧ Тогда
			РеквизитТЧ = РеквизитФормы;
			НаименованиеТЧ = РеквизитТЧ.Заголовок;
		КонецЕсли;
	КонецЦикла;
	Если РеквизитТЧ <> Неопределено Тогда
		РеквизитыФормы = Форма.ПолучитьРеквизиты(РеквизитТЧ.Имя);
		Для каждого РеквизитФормы Из РеквизитыФормы Цикл
			Если РеквизитФормы.Имя = ИмяПоля Тогда
				РеквизитПоля = РеквизитФормы;
				НаименованиеПоля = РеквизитПоля.Заголовок;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Для каждого СтрокаТЧ Из Форма[ИмяТЧ] Цикл
		Если Вычислить(УсловиеПроверки) Тогда
			Отказ = Истина;
			Сообщение = Новый СообщениеПользователю;
			Сообщение.Текст = "Не заполнено поле """ + НаименованиеПоля + """ в строке " + (Форма[ИмяТЧ].Индекс(СтрокаТЧ) + 1) + " табличной части """ + НаименованиеТЧ + """.";
			Сообщение.Поле = ИмяТЧ + "[" + Форма[ИмяТЧ].Индекс(СтрокаТЧ) + "]." + ИмяПоля;
			Сообщение.Сообщить();
		КонецЕсли;
	КонецЦикла;
	
	
КонецПроцедуры

Процедура ПроверитьЗаполнениеРеквизитаФормы(ИмяПоля, НаименованиеПоля, Значение, Отказ, УсловиеПроверки = "Не ЗначениеЗаполнено(Значение)") Экспорт
	
	Если Вычислить(УсловиеПроверки) Тогда
		Отказ = Истина;
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст = "Не заполнено поле """ + НаименованиеПоля + """.";
		Сообщение.Поле = ИмяПоля;
		Сообщение.Сообщить();
	КонецЕсли;
	
КонецПроцедуры

Процедура УстановитьПроверкуЗаполненияРеквизита(ПроверяемыеРеквизиты, ИмяРеквизита, Проверять) Экспорт
	Если Проверять Тогда
		ДобавитьРеквизитДляПроверкиЗаполнения(ПроверяемыеРеквизиты, ИмяРеквизита);
	Иначе
		УдалитьРеквизитДляПроверкиЗаполнения(ПроверяемыеРеквизиты, ИмяРеквизита);
	КонецЕсли;
КонецПроцедуры

// БоР : Используется в процедурах ОбработкаПроверкиЗаполнения 05.09.2013 13:48:20
Процедура ДобавитьРеквизитДляПроверкиЗаполнения(ПроверяемыеРеквизиты, ИмяРеквизита) Экспорт
	Реквизит = ПроверяемыеРеквизиты.Найти(ИмяРеквизита);
	Если Реквизит = Неопределено Тогда
		ПроверяемыеРеквизиты.Добавить(ИмяРеквизита);
	КонецЕсли;
КонецПроцедуры

// БоР : Используется в процедурах ОбработкаПроверкиЗаполнения 05.09.2013 13:48:20
Процедура УдалитьРеквизитДляПроверкиЗаполнения(ПроверяемыеРеквизиты, ИмяРеквизита) Экспорт
	Реквизит = ПроверяемыеРеквизиты.Найти(ИмяРеквизита);
	Если Реквизит <> Неопределено Тогда
		ПроверяемыеРеквизиты.Удалить(Реквизит);
	КонецЕсли;
КонецПроцедуры
#КонецОбласти

#Область СКД_Отборы_Всякое_близкое

// БоР : Извлекает из отчета СКД и кладет в хранилище 11.02.2014 1:26:24
Функция ПолучитьСхемуКомпоновкиОтчета(ИмяОтчета, ИмяМакета, УникальныйИдентификатор) Экспорт
	СхемаКомпоновкиДанных = Отчеты[ИмяОтчета].ПолучитьМакет(ИмяМакета);
	ВозВрат ПоместитьВоВременноеХранилище(СхемаКомпоновкиДанных, УникальныйИдентификатор);
КонецФункции

#Область Перенесено_в_БоР_ОбщийМодульКлиентСервер
//// БоР : Находит и возвращает все элементы отбора (только в линейной структуре, не учитывая содержимое групп) 09.05.2012 15:06:48
//Функция НайтиЭлементыОтбора(ЭлементСтруктуры, ПолеОтбора, ВидСравнения = Неопределено, ЗначениеОтбора = Неопределено, Использование = Неопределено, Представление = Неопределено) Экспорт
//	
//	Если ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппировкаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ТаблицаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ДиаграммаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Настройки.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Настройки.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ОтборКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	Иначе// предполагаем, что это что-то, у чего есть поле "Отбор"
//		Отбор = ЭлементСтруктуры.Отбор;
//	КонецЕсли;
//	
//	Если ТипЗнч(ПолеОтбора) = Тип("Строка") Тогда
//		ПолеОтбора = Новый ПолеКомпоновкиДанных(ПолеОтбора);
//	КонецЕсли;
//	
//	МассивЭлементовОтбора = Новый Массив;
//	Для каждого ЭлементОтбора Из Отбор.Элементы Цикл
//		Если ТипЗнч(ЭлементОтбора) <> Тип("ЭлементОтбораКомпоновкиДанных") Тогда
//			// группы элементов ищем только по представлению
//			Если Представление <> Неопределено И ЭлементОтбора.Представление = Представление Тогда
//				МассивЭлементовОтбора.Добавить(ЭлементОтбора);
//				Продолжить;
//			КонецЕсли;
//			Продолжить;
//		КонецЕсли;
//		Если ВидСравнения <> Неопределено И ЭлементОтбора.ВидСравнения <> ВидСравнения Тогда
//			Продолжить;
//		КонецЕсли;
//		Если Представление <> Неопределено И ЭлементОтбора.Представление <> Представление Тогда
//			Продолжить;
//		КонецЕсли;
//		Если Использование <> Неопределено И ЭлементОтбора.Использование <> Использование Тогда
//			Продолжить;
//		КонецЕсли;
//		Если ЗначенияРавны(ЭлементОтбора.ЛевоеЗначение, ПолеОтбора) И (ЗначениеОтбора = Неопределено ИЛИ ЗначенияРавны(ЭлементОтбора.ПравоеЗначение, ЗначениеОтбора)) Тогда
//			МассивЭлементовОтбора.Добавить(ЭлементОтбора);
//			Продолжить;
//		КонецЕсли;
//		Если (ЗначениеОтбора = Неопределено ИЛИ ЗначенияРавны(ЭлементОтбора.ЛевоеЗначение, ЗначениеОтбора)) И ЗначенияРавны(ЭлементОтбора.ПравоеЗначение, ПолеОтбора) Тогда
//			МассивЭлементовОтбора.Добавить(ЭлементОтбора);
//			Продолжить;
//		КонецЕсли;
//	КонецЦикла;
//	ВозВрат МассивЭлементовОтбора;
//	
//КонецФункции // ПолучитьЭлементОтбора()

//// БоР : Добавляет в отбор элемент отбора по определенному полю 09.07.2009 14:01:22
//Функция ДобавитьЭлементОтбора(ЭлементСтруктуры, ПолеОтбора, ВидСравнения = Неопределено, ЗначениеОтбора = Неопределено, УдалятьСуществующие = Истина, Использование = Истина, Представление = Неопределено, ПользовательскаяНастройка = Ложь) Экспорт
//	
//	Если ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппировкаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ТаблицаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ДиаграммаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Настройки.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Настройки.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ОтборКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	Иначе// предполагаем, что это что-то, у чего есть поле "Отбор"
//		Отбор = ЭлементСтруктуры.Отбор;
//	КонецЕсли;
//	
//	Если ТипЗнч(ПолеОтбора) = Тип("Строка") Тогда
//		ПолеОтбора = Новый ПолеКомпоновкиДанных(ПолеОтбора);
//	КонецЕсли;
//	
//	Если ВидСравнения = Неопределено Тогда
//		ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
//	КонецЕсли;
//	
//	Если УдалятьСуществующие Тогда
//		МассивЭлементовОтбора = НайтиЭлементыОтбора(Отбор, ПолеОтбора, , , , Представление);
//		Для каждого ЭлементОтбора Из МассивЭлементовОтбора Цикл
//			Отбор.Элементы.Удалить(ЭлементОтбора);
//		КонецЦикла;
//	КонецЕсли;
//	
//	НовыйЭлементОтбора = Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
//	Если ПользовательскаяНастройка <> Ложь Тогда
//		НовыйЭлементОтбора.ИдентификаторПользовательскойНастройки = ?(ПользовательскаяНастройка = Истина, Строка(Новый УникальныйИдентификатор), ПользовательскаяНастройка);
//	КонецЕсли;
//	НовыйЭлементОтбора.Использование  = Использование;
//	НовыйЭлементОтбора.ВидСравнения   = ВидСравнения;
//	НовыйЭлементОтбора.ЛевоеЗначение  = ПолеОтбора;
//	НовыйЭлементОтбора.ПравоеЗначение = ЗначениеОтбора;
//	НовыйЭлементОтбора.Представление  = Представление;
//	ВозВрат НовыйЭлементОтбора;
//КонецФункции // ДобавитьЭлементОтбора()

//// БоР :  21.07.2017 14:02:58
//Функция УдалитьЭлементОтбора(ЭлементСтруктуры, ПолеОтбора, Представление = Неопределено) Экспорт
//	
//	Если ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппировкаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ТаблицаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ДиаграммаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Настройки.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Настройки.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ОтборКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	Иначе// предполагаем, что это что-то, у чего есть поле "Отбор"
//		Отбор = ЭлементСтруктуры.Отбор;
//	КонецЕсли;
//	
//	Если ТипЗнч(ПолеОтбора) = Тип("Строка") Тогда
//		ПолеОтбора = Новый ПолеКомпоновкиДанных(ПолеОтбора);
//	КонецЕсли;
//	
//	МассивЭлементовОтбора = НайтиЭлементыОтбора(Отбор, ПолеОтбора, , , , Представление);
//	Для каждого ЭлементОтбора Из МассивЭлементовОтбора Цикл
//		Отбор.Элементы.Удалить(ЭлементОтбора);
//	КонецЦикла;
//	
//	ВозВрат Неопределено;
//	
//КонецФункции

//// БоР :  21.07.2017 14:02:58
//Функция УстановитьОтборПоПолю(ЭлементСтруктуры, Поле, Значение, ПользовательскаяНастройка = Ложь, Представление = "", ВидСравнения = Неопределено, УстанавливатьОтбор = Истина) Экспорт
//	Если ЗначениеЗаполнено(Значение) Тогда
//		ЭлементОтбора = УдалитьЭлементОтбора(ЭлементСтруктуры, Поле, ?(Представление = "", "Отбор по полю " + Поле, Представление));
//	Иначе
//		ЭлементОтбора = ДобавитьЭлементОтбора(ЭлементСтруктуры, Поле, ?(ВидСравнения = Неопределено, ВидСравненияКомпоновкиДанных.Равно, ВидСравнения), Значение, Истина, УстанавливатьОтбор, ?(Представление = "", "Отбор по полю " + Поле, Представление), ПользовательскаяНастройка);
//	КонецЕсли;
//	ВозВрат ЭлементОтбора;
//КонецФункции

//// БоР : Добавляет в отбор элемент отбора по определенному полю 09.07.2009 14:01:22
//Функция ДобавитьГруппуОтбора(ЭлементСтруктуры, ТипГруппы, УдалятьСуществующие = Истина, Использование = Истина, Представление = Неопределено, ПользовательскаяНастройка = Ложь) Экспорт
//	
//	Если ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппировкаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ТаблицаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ДиаграммаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Настройки.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Настройки.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ОтборКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	Иначе// предполагаем, что это что-то, у чего есть поле "Отбор"
//		Отбор = ЭлементСтруктуры.Отбор;
//	КонецЕсли;
//	
//	Если УдалятьСуществующие Тогда
//		МассивЭлементовОтбора = НайтиЭлементыОтбора(Отбор, , , , , Представление);
//		Для каждого ЭлементОтбора Из МассивЭлементовОтбора Цикл
//			Отбор.Элементы.Удалить(ЭлементОтбора);
//		КонецЦикла;
//	КонецЕсли;
//	
//	НовыйЭлементОтбора = Отбор.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
//	НовыйЭлементОтбора.Использование	= Использование;
//	НовыйЭлементОтбора.ТипГруппы		= ТипГруппы;
//	НовыйЭлементОтбора.Представление	= Представление;
//	Если ПользовательскаяНастройка <> Ложь Тогда
//		НовыйЭлементОтбора.ИдентификаторПользовательскойНастройки = ?(ПользовательскаяНастройка = Истина, Строка(Новый УникальныйИдентификатор), ПользовательскаяНастройка);
//	КонецЕсли;
//	ВозВрат НовыйЭлементОтбора;
//КонецФункции // ДобавитьЭлементОтбора()

//// БоР : Настраивает параметры данных компоновщика (те что с "&") 04.10.2009 21:39:59
//Процедура НастроитьПараметрыДанныхКомпоновки(Объект, СтруктураПараметров, ПользовательскаяНастройка = Ложь) Экспорт
//	Если ТипЗнч(Объект) = Тип("НастройкиКомпоновкиДанных") Тогда
//		Настройки = Объект;
//	ИначеЕсли ТипЗнч(Объект) = Тип("ГруппировкаКомпоновкиДанных") Тогда
//		Настройки = Объект;
//	ИначеЕсли ТипЗнч(Объект) = Тип("ТаблицаКомпоновкиДанных") Тогда
//		Настройки = Объект;
//	ИначеЕсли ТипЗнч(Объект) = Тип("ДиаграммаКомпоновкиДанных") Тогда
//		Настройки = Объект;
//	ИначеЕсли ТипЗнч(Объект) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
//		Настройки = Объект.Настройки;
//	Иначе// предполагаем, что это отчет или что-то подобное, у чего есть поле "КомпоновщикНастроек"
//		Настройки = Объект.КомпоновщикНастроек.Настройки;
//	КонецЕсли;
//	Для каждого Параметр Из СтруктураПараметров Цикл
//		Если Настройки.ПараметрыДанных.ДоступныеПараметры <> Неопределено Тогда
//			Если Настройки.ПараметрыДанных.ДоступныеПараметры.Элементы.Найти(Параметр.Ключ) = Неопределено Тогда
//				Продолжить;
//			КонецЕсли;
//		КонецЕсли;
//		НовыйПараметр = Настройки.ПараметрыДанных.Элементы.Найти(Параметр.Ключ);
//		Если НовыйПараметр = Неопределено Тогда
//			НовыйПараметр = Настройки.ПараметрыДанных.Элементы.Добавить();
//			НовыйПараметр.Параметр      = Новый ПараметрКомпоновкиДанных(Параметр.Ключ);
//		КонецЕсли;
//		НовыйПараметр.Использование = Истина;
//		НовыйПараметр.Значение      = Параметр.Значение;
//		Если ПользовательскаяНастройка <> Ложь Тогда
//			НовыйПараметр.ИдентификаторПользовательскойНастройки = ?(ПользовательскаяНастройка = Истина, Строка(Новый УникальныйИдентификатор), ПользовательскаяНастройка);
//		КонецЕсли;
//	КонецЦикла;
//КонецПроцедуры

//// БоР : Извлекает параметры данных компоновщика (из тех что с "&") 04.10.2009 21:39:59
//функция ПолучитьПараметрыДанныхКомпоновки(Объект) Экспорт
//	Если ТипЗнч(Объект) = Тип("НастройкиКомпоновкиДанных") Тогда
//		Настройки = Объект;
//	ИначеЕсли ТипЗнч(Объект) = Тип("ГруппировкаКомпоновкиДанных") Тогда
//		Настройки = Объект;
//	ИначеЕсли ТипЗнч(Объект) = Тип("ТаблицаКомпоновкиДанных") Тогда
//		Настройки = Объект;
//	ИначеЕсли ТипЗнч(Объект) = Тип("ДиаграммаКомпоновкиДанных") Тогда
//		Настройки = Объект;
//	ИначеЕсли ТипЗнч(Объект) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
//		Настройки = Объект.Настройки;
//	Иначе// предполагаем, что это отчет или что-то подобное, у чего есть поле "КомпоновщикНастроек"
//		Настройки = Объект.КомпоновщикНастроек.Настройки;
//	КонецЕсли;
//	СтруктураПараметров = Новый Структура;
//	Для каждого Параметр Из Настройки.ПараметрыДанных.Элементы Цикл
//		СтруктураПараметров.Вставить(Параметр.Параметр, Параметр.Значение);
//	КонецЦикла;
//	ВозВрат СтруктураПараметров;
//КонецФункции

//// БоР : Извлекает параметр данных компоновщика (из тех что с "&") 04.10.2009 21:39:59
//Функция ПолучитьПараметрДанныхКомпоновки(Объект, ИмяПараметра) Экспорт
//	СтруктураПараметров = ПолучитьПараметрыДанныхКомпоновки(Объект);
//	ЗначениеПараметра = Неопределено;
//	СтруктураПараметров.Свойство(ИмяПараметра, ЗначениеПараметра);
//	ВозВрат ЗначениеПараметра;
//КонецФункции
#КонецОбласти

// БоР : Получение таблицы данных из компоновщика. Вариант с передачей Схемы и настроек (без использования промежуточного объекта) 09.01.2012 17:59:59
Функция ПолучитьРезультатКомпоновкиКакТабличныйДокумент(СхемаКомпоновкиДанных, Настройки, ДанныеРасшифровки = Неопределено, ОтображатьПроцентВывода = Истина) Экспорт
	
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	МакетКомпоновки = КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, Настройки, ДанныеРасшифровки, , Тип("ГенераторМакетаКомпоновкиДанных"));
	
	ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновки.Инициализировать(МакетКомпоновки, , ДанныеРасшифровки, Истина);
	
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВТабличныйДокумент;
	ПроцессорВывода.ОтображатьПроцентВывода = ОтображатьПроцентВывода;
	ПроцессорВывода.УстановитьДокумент(Новый ТабличныйДокумент);
	ВозВрат ПроцессорВывода.Вывести(ПроцессорКомпоновки);	
	
КонецФункции

// БоР : Получение таблицы данных из компоновщика. Вариант с передачей Схемы и настроек (без использования промежуточного объекта) 09.01.2012 17:59:59
Функция ПолучитьРезультатКомпоновкиКакТЗ(СхемаКомпоновкиДанных, Настройки, ОтображатьПроцентВывода = Истина) Экспорт
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	МакетКомпоновки = КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, Настройки,,,Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
	
	ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновки.Инициализировать(МакетКомпоновки,,,Истина);
	
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	ПроцессорВывода.ОтображатьПроцентВывода = ОтображатьПроцентВывода;
	ПроцессорВывода.УстановитьОбъект(Новый ТаблицаЗначений);
	ВозВрат ПроцессорВывода.Вывести(ПроцессорКомпоновки);	
	
КонецФункции

// БоР : Получение таблицы данных из компоновщика. Вариант с передачей Схемы и настроек (без использования промежуточного объекта) 09.01.2012 17:59:59
Функция ПолучитьРезультатКомпоновкиКакДЗ(СхемаКомпоновкиДанных, Настройки, ОтображатьПроцентВывода = Истина) Экспорт
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	МакетКомпоновки = КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, Настройки,,,Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
	
	ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновки.Инициализировать(МакетКомпоновки,,,Истина);
	
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	ПроцессорВывода.ОтображатьПроцентВывода = ОтображатьПроцентВывода;
	ПроцессорВывода.УстановитьОбъект(Новый ДеревоЗначений);
	ВозВрат ПроцессорВывода.Вывести(ПроцессорКомпоновки);	
	
КонецФункции

// БоР : Просматривает варианты компоновки и выдает по имени или первый, если по имени не найден 14.06.2011 18:05:45
Функция ПолучитьВариантКомпоновки(СхемаКомпоновки, ИмяВариантаНастройки = Неопределено) Экспорт
	Если ИмяВариантаНастройки <> Неопределено Тогда
		Для каждого Вариант Из СхемаКомпоновки.ВариантыНастроек Цикл
			Если Вариант.Имя = ИмяВариантаНастройки Тогда
				ВозВрат Вариант;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	ВозВрат СхемаКомпоновки.ВариантыНастроек[0];
КонецФункции //ПолучитьОбработчик()
#КонецОбласти

// БоР : Сравнивает значения, в том числе и содержимое списков (без учета сортировки) 09.05.2012 15:10:38
Функция ЗначенияРавны(Значение1, Значение2) Экспорт
	
	Если ТипЗнч(Значение1) <> ТипЗнч(Значение2) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипЗнч(Значение1) = Тип("СписокЗначений") Тогда
		Если Значение1.Количество() <> Значение2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого Элемент1 Из Значение1 Цикл
			Для каждого Элемент2 Из Значение2 Цикл
				Если ЗначенияРавны(Элемент1.Значение, Элемент2.Значение) Тогда
					Найден = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Не Найден Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Для каждого Элемент2 Из Значение2 Цикл
			Для каждого Элемент1 Из Значение1 Цикл
				Если ЗначенияРавны(Элемент2.Значение, Элемент1.Значение) Тогда
					Найден = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Не Найден Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
	ИначеЕсли ТипЗнч(Значение1) = Тип("Массив") Тогда
		Если Значение1.Количество() <> Значение2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого Элемент1 Из Значение1 Цикл
			Для каждого Элемент2 Из Значение2 Цикл
				Если ЗначенияРавны(Элемент1, Элемент2) Тогда
					Найден = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Не Найден Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Для каждого Элемент2 Из Значение2 Цикл
			Для каждого Элемент1 Из Значение1 Цикл
				Если ЗначенияРавны(Элемент2, Элемент1) Тогда
					Найден = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Не Найден Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
	ИначеЕсли ТипЗнч(Значение1) = Тип("Структура") Тогда
		Если Значение1.Количество() <> Значение2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		Для каждого Элемент1 Из Значение1 Цикл
			ТекущееЗначение = Неопределено;
			Если НЕ Значение2.Свойство(Элемент1.Ключ, ТекущееЗначение) Тогда
				Возврат Ложь;
			КонецЕсли;
			Если Не ЗначенияРавны(Значение1.Значение, ТекущееЗначение) Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		Возврат Истина;
	Иначе
		Возврат Значение1 = Значение2;
	КонецЕсли;
	Возврат Ложь;
	
КонецФункции

// БоР : Находит очередную невыполненную задачу 19.06.2012 1:31:55
Функция ПолучитьОчереднуюЗадачу(БизнесПроцесс, ТочкаМаршрута = Неопределено, ПризнакВыполнения = Неопределено) Экспорт

	ИмяЗадачи = БизнесПроцесс.Метаданные().Задача.Имя;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	Задача.Ссылка
	|ИЗ
	|	Задача." + ИмяЗадачи + " КАК Задача
	|ГДЕ
	|	Задача.БизнесПроцесс = &БизнесПроцесс
	|	И (Задача.ТочкаМаршрута = &ТочкаМаршрута
	|			ИЛИ &ТочкаМаршрута = НЕОПРЕДЕЛЕНО)
	|	И (НЕ Задача.Выполнена = &ПризнакВыполнения
	|			ИЛИ &ПризнакВыполнения = НЕОПРЕДЕЛЕНО)
	|	И НЕ Задача.ПометкаУдаления";
	
	Запрос.УстановитьПараметр("БизнесПроцесс"		, БизнесПроцесс);
	Запрос.УстановитьПараметр("ТочкаМаршрута"		, ТочкаМаршрута);
	Запрос.УстановитьПараметр("ПризнакВыполнения"	, ПризнакВыполнения);

	Результат = Запрос.Выполнить();
	
	ВыборкаДетальныеЗаписи = Результат.Выбрать();
	
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		ВозВрат ВыборкаДетальныеЗаписи.Ссылка;
	КонецЦикла;
	ВозВрат Задачи[ИмяЗадачи].ПустаяСсылка();
	
КонецФункции

Функция ЕстьРеквизитОбъекта(ИмяРеквизита, МетаданныеОбъекта, ПроверитьДляГруппы = Неопределено) Экспорт

	ВозВрат Бор_ПовторноеИспользованиеСервер.ЕстьРеквизитОбъекта(ИмяРеквизита, МетаданныеОбъекта.ПолноеИмя(), ПроверитьДляГруппы);

КонецФункции // ЕстьРеквизитДокумента()

Функция ПолучитьПолеОбъекта(СсылкаНаОбъект, ИмяПоля) Экспорт
	// особых проверок не будем делать
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоля = СсылкаНаОбъект;
		МассивПолей = СтрРазделить(ИмяПоля, ".");
		Для каждого ИмяОчередногоПоля Из МассивПолей Цикл
			Попытка
				ЗначениеПоля = ЗначениеПоля[СокрЛП(ИмяОчередногоПоля)];
			Исключение
				ВозВрат Неопределено;
			КонецПопытки;
		КонецЦикла;
		ВозВрат ЗначениеПоля;
	КонецЕсли;
КонецФункции

Функция ПолучитьПоляОбъекта_Соответствие(СсылкаНаОбъект, Знач ИменаПолей) Экспорт
	// особых проверок не будем делать
	Если Не ЗначениеЗаполнено(ИменаПолей) Тогда
		ВозВрат Новый Соответствие;
	КонецЕсли;
	
	Если ТипЗнч(ИменаПолей) = Тип("Строка") Тогда
		МассивПутей = БоР_ОбщийМодульКлиентСервер.РазобратьСтрокуНаСловаНовая(ИменаПолей, ",");
		СоответствиеРеквизитов = Новый Соответствие;
		Для каждого Путь Из МассивПутей Цикл
			СоответствиеРеквизитов.Вставить(Путь);
		КонецЦикла;
	ИначеЕсли ТипЗнч(ИменаПолей) = Тип("Соответствие") Тогда
		СоответствиеРеквизитов = ИменаПолей;
	ИначеЕсли ТипЗнч(ИменаПолей) = Тип("ФиксированноеСоответствие") Тогда
		СоответствиеРеквизитов = Новый Соответствие(ИменаПолей);
	ИначеЕсли ТипЗнч(ИменаПолей) = Тип("Структура") ИЛИ ТипЗнч(ИменаПолей) = Тип("ФиксированнаяСтруктура") Тогда
		СоответствиеРеквизитов = Новый Соответствие;
		Для каждого Путь Из ИменаПолей Цикл
			СоответствиеРеквизитов.Вставить(Путь.Ключ);
		КонецЦикла;
	ИначеЕсли ТипЗнч(ИменаПолей) = Тип("Массив") ИЛИ ТипЗнч(ИменаПолей) = Тип("ФиксированныйМассив") Тогда
		СоответствиеРеквизитов = Новый Соответствие;
		Для каждого Путь Из ИменаПолей Цикл
			СоответствиеРеквизитов.Вставить(Путь);
		КонецЦикла;
	Иначе
		ВозВрат Новый Соответствие;
	КонецЕсли;
	
	ТекстПолей = "";
	Для Каждого Реквизит Из СоответствиеРеквизитов Цикл
		Псевдоним = СтрЗаменить(СокрЛП(Реквизит.Ключ), ".", "");
		СоответствиеРеквизитов.Вставить(Реквизит.Ключ, Псевдоним);
		ТекстПолей  = ТекстПолей
		+ ?(Не ЗначениеЗаполнено(ТекстПолей), "", ",")
		+ "
		|	" + Реквизит.Ключ + " КАК " + Псевдоним;
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("СсылкаНаОбъект", СсылкаНаОбъект);
	Запрос.Текст =
	"ВЫБРАТЬ" + ТекстПолей + "
	|ИЗ
	|	" + СсылкаНаОбъект.Метаданные().ПолноеИмя() + " КАК _ТаблицаОбъекта_
	|ГДЕ
	|	_ТаблицаОбъекта_.Ссылка = &СсылкаНаОбъект
	|";
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Для Каждого Реквизит Из СоответствиеРеквизитов Цикл
		СоответствиеРеквизитов.Вставить(Реквизит.Ключ, Выборка[Реквизит.Значение]);
	КонецЦикла;
	ВозВрат СоответствиеРеквизитов;
	
КонецФункции

Функция ПолучитьПоляОбъекта(СсылкаНаОбъект, Знач ИменаПолей) Экспорт
	// особых проверок не будем делать
	Если Не ЗначениеЗаполнено(ИменаПолей) Тогда
		ВозВрат Новый Структура;
	КонецЕсли;
	
	Если ТипЗнч(ИменаПолей) = Тип("Строка") Тогда
		МассивПутей = БоР_ОбщийМодульКлиентСервер.РазобратьСтрокуНаСловаНовая(ИменаПолей, ",");
		СтруктураРеквизитов = Новый Структура;
		Для каждого Путь Из МассивПутей Цикл
			ПутьПоля = СокрЛП(Путь);
			Псевдоним = СтрЗаменить(СокрЛП(ПутьПоля), ".", "");
			СтруктураРеквизитов.Вставить(Псевдоним, ПутьПоля);
		КонецЦикла;
	ИначеЕсли ТипЗнч(ИменаПолей) = Тип("Соответствие") ИЛИ ТипЗнч(ИменаПолей) = Тип("ФиксированноеСоответствие") ИЛИ ТипЗнч(ИменаПолей) = Тип("Структура") ИЛИ ТипЗнч(ИменаПолей) = Тип("ФиксированнаяСтруктура") Тогда
		СтруктураРеквизитов = Новый Структура;
		Для каждого Путь Из ИменаПолей Цикл
			ПутьПоля = СокрЛП(Путь.Ключ);
			Псевдоним = СтрЗаменить(СокрЛП(ПутьПоля), ".", "");
			СтруктураРеквизитов.Вставить(Псевдоним, ПутьПоля);
		КонецЦикла;
	ИначеЕсли ТипЗнч(ИменаПолей) = Тип("Массив") ИЛИ ТипЗнч(ИменаПолей) = Тип("ФиксированныйМассив") Тогда
		СтруктураРеквизитов = Новый Структура;
		Для каждого Путь Из МассивПутей Цикл
			ПутьПоля = СокрЛП(Путь);
			Псевдоним = СтрЗаменить(СокрЛП(ПутьПоля), ".", "");
			СтруктураРеквизитов.Вставить(Псевдоним, ПутьПоля);
		КонецЦикла;
	Иначе
		ВозВрат Новый Структура;
	КонецЕсли;
	
	ТекстПолей = "";
	Для Каждого Реквизит Из СтруктураРеквизитов Цикл
		ТекстПолей  = ТекстПолей
		+ ?(Не ЗначениеЗаполнено(ТекстПолей), "", ",")
		+ "
		|	" + Реквизит.Значение + " КАК " + Реквизит.Ключ;
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("СсылкаНаОбъект", СсылкаНаОбъект);
	Запрос.Текст =
	"ВЫБРАТЬ" + ТекстПолей + "
	|ИЗ
	|	" + СсылкаНаОбъект.Метаданные().ПолноеИмя() + " КАК _ТаблицаОбъекта_
	|ГДЕ
	|	_ТаблицаОбъекта_.Ссылка = &СсылкаНаОбъект
	|";
	Выборка = Запрос.Выполнить().Выбрать();
	//Фурман 2018-04-25-09-33 {
	//Было:
	//Выборка.Следующий();
	//Для Каждого Реквизит Из СтруктураРеквизитов Цикл
	//	СтруктураРеквизитов.Вставить(Реквизит.Ключ, Выборка[Реквизит.Ключ]);
	//КонецЦикла;
	// В случае пустой ссылки получаем реквизиты через СсылкаНаОбъект 
	Если Выборка.Следующий() Тогда
		Для Каждого Реквизит Из СтруктураРеквизитов Цикл
			СтруктураРеквизитов.Вставить(Реквизит.Ключ, Выборка[Реквизит.Ключ]);
		КонецЦикла;
	Иначе
		Для Каждого Реквизит Из СтруктураРеквизитов Цикл
			Попытка
				ЗначениеПоля = СсылкаНаОбъект[Реквизит.Ключ];
			Исключение
				ЗначениеПоля = Неопределено;
			КонецПопытки;
			СтруктураРеквизитов.Вставить(Реквизит.Ключ, ЗначениеПоля);
		КонецЦикла;
	КонецЕсли;
	//}Фурман 2018-04-25-09-33
	
	ВозВрат СтруктураРеквизитов;
	
КонецФункции

// БоР : Помещает в структуру все поля из объектов типа менеджер записи, запись, строка набора записей 19.07.2014 0:36:28
// БоР : Некотроые поля пока не добавляются - по мере необходимости добавим 19.07.2014 0:36:28
Функция СтруктураПолейЗаписиРегистра(ДанныеЗаписи, ТолькоКлючевыеПоля = Неопределено, ДобавлятьСистемные = Ложь) Экспорт
	
	СтруктураПолей = Новый Структура;
	ТипЗначенияДанных = ТипЗнч(ДанныеЗаписи);
	
	МетаданныеРегистра = Метаданные.НайтиПоТипу(ТипЗначенияДанных);
	Если МетаданныеРегистра = Неопределено Тогда
		ВозВрат СтруктураПолей;
	КонецЕсли;
	
	Если Метаданные.РегистрыСведений.Содержит(МетаданныеРегистра) Тогда
		ТипРегистра = "РегистрСведений";
	ИначеЕсли Метаданные.РегистрыНакопления.Содержит(МетаданныеРегистра) Тогда
		ТипРегистра = "РегистрНакопления";
	ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(МетаданныеРегистра) Тогда
		ТипРегистра = "РегистрБухгалтерии";
	ИначеЕсли Метаданные.РегистрыРасчета.Содержит(МетаданныеРегистра) Тогда
		ТипРегистра = "РегистрРасчета";
	Иначе
		ВозВрат СтруктураПолей;
	КонецЕсли;
	
	Если ТолькоКлючевыеПоля = Неопределено Тогда
		Если ТипЗначенияДанных = Тип(ТипРегистра + "КлючЗаписи." + МетаданныеРегистра.Имя) Тогда
			ТолькоКлючевыеПоля = Истина;
		Иначе
			ТолькоКлючевыеПоля = Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Если Метаданные.РегистрыСведений.Содержит(МетаданныеРегистра) Тогда
		Если МетаданныеРегистра.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
			СтруктураПолей.Вставить("Период");
		КонецЕсли;
		Если ДобавлятьСистемные И МетаданныеРегистра.РежимЗаписи <> Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору Тогда
			СтруктураПолей.Вставить("Регистратор");
		КонецЕсли;
	ИначеЕсли Метаданные.РегистрыНакопления.Содержит(МетаданныеРегистра) Тогда
		СтруктураПолей.Вставить("Период");
		Если ДобавлятьСистемные Тогда
			СтруктураПолей.Вставить("Регистратор");
		КонецЕсли;
		Если ДобавлятьСистемные И МетаданныеРегистра.РежимЗаписи <> Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
			СтруктураПолей.Вставить("ВидДвижения");
		КонецЕсли;
	КонецЕсли;
	Для Каждого Поле Из МетаданныеРегистра.Измерения Цикл
		СтруктураПолей.Вставить(Поле.Имя);
	КонецЦикла;
	Если Не ТолькоКлючевыеПоля Тогда
		Для Каждого Поле Из МетаданныеРегистра.Ресурсы Цикл
			СтруктураПолей.Вставить(Поле.Имя);
		КонецЦикла;
		Для Каждого Поле Из МетаданныеРегистра.Реквизиты Цикл
			СтруктураПолей.Вставить(Поле.Имя);
		КонецЦикла;
	КонецЕсли;
	ЗаполнитьЗначенияСвойств(СтруктураПолей, ДанныеЗаписи);
	
	Возврат СтруктураПолей;
	
КонецФункции

// БоР : Функция возвращает все значения перечисления в виде структуры, в основном для использования на клиенте, через модуль с повторно возвращаемыми значениями 13.04.2016 16:09:38
Функция ПолучитьЗначенияПеречисления(ИмяПеречисления, ДобавлятьПустое = Истина, ИмяПустого = "ПустаяСсылка") Экспорт
	// БоР : Для скорости не проверяем ничего на корректность, все на совести вызывающего контекста 13.04.2016 16:15:29
	ЗначенияПеречисления = Новый Структура;
	Для каждого ЗначениеПеречисления Из Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления Цикл
		ЗначенияПеречисления.Вставить(ЗначениеПеречисления.Имя, Перечисления[ИмяПеречисления][ЗначениеПеречисления.Имя]);
	КонецЦикла;
	Если ДобавлятьПустое Тогда
		ЗначенияПеречисления.Вставить(ИмяПустого, Перечисления[ИмяПеречисления].ПустаяСсылка());
	КонецЕсли;
	ВозВрат ЗначенияПеречисления;
КонецФункции

// БоР : Выясняет, группа ли передана в параметре, проверяясь попутно, справочник ли это 25.08.2013 23:42:08
Функция ЭтоГруппа(СсылкаНаСправочник) Экспорт
	Если СсылкаНаСправочник = Неопределено Тогда
		ВозВрат Неопределено;
	ИначеЕсли Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(СсылкаНаСправочник)) Тогда
		ВозВрат СсылкаНаСправочник.ЭтоГруппа;
	Иначе
		ВозВрат Неопределено;
	КонецЕсли;
КонецФункции

// БоР : Составляет список из всех уровней, в которых находится элемент справочника 04.09.2013 5:15:16
Функция ПолучитьВсехРодителейЭлементаСправочника(ЭлементСправочника, ВключатьСамЭлемент = Истина) Экспорт
	МассивЭлементов = Новый СписокЗначений;
	Если ВключатьСамЭлемент Тогда
		МассивЭлементов.Вставить(0, ЭлементСправочника);
	КонецЕсли;
	ТекущийРодитель = ЭлементСправочника.Родитель;
	Пока ЗначениеЗаполнено(ТекущийРодитель) Цикл
		МассивЭлементов.Вставить(0, ТекущийРодитель);
		ТекущийРодитель = ТекущийРодитель.Родитель;
	КонецЦикла;
	
	ВозВрат МассивЭлементов;
		
КонецФункции

Процедура ЗаполнитьРеквизит(Объект, МетаданныеОбъекта, Пользователь, ДанныеЗаполнения, ИмяРеквизита, ИмяНастройки, ИмяПараметраСеанса, ЗначениеПоУмолчанию = Неопределено) Экспорт
	Если Метаданные.Справочники.Содержит(МетаданныеОбъекта) И МетаданныеОбъекта.Иерархический Тогда
		ПроверитьДляГруппы = Объект.ЭтоГруппа;
	Иначе
		ПроверитьДляГруппы = Неопределено
	КонецЕсли;
	Если Не ЕстьРеквизитОбъекта(ИмяРеквизита, МетаданныеОбъекта, ПроверитьДляГруппы) Тогда
		ВозВрат;
	КонецЕсли;
	Если ТипЗнч(ДанныеЗаполнения) = Тип("Структура") ИЛИ ТипЗнч(ДанныеЗаполнения) = Тип("ФиксированнаяСтруктура") Тогда
		Если ДанныеЗаполнения.Свойство(ИмяРеквизита) И ЗначениеЗаполнено(ДанныеЗаполнения[ИмяРеквизита]) И Не МетаданныеОбъекта.Реквизиты[ИмяРеквизита].ЗаполнятьИзДанныхЗаполнения Тогда
			Объект[ИмяРеквизита] = ДанныеЗаполнения[ИмяРеквизита];
		КонецЕсли;
	ИначеЕсли ТипЗнч(ДанныеЗаполнения) = ТипЗнч(Объект) Тогда
		Если ЗначениеЗаполнено(ДанныеЗаполнения[ИмяРеквизита]) Тогда
			ВозВрат;
		КонецЕсли;
	КонецЕсли;
	Если ЗначениеЗаполнено(Объект[ИмяРеквизита]) Тогда
		ВозВрат;
	КонецЕсли;
	ЗначениеПараметраСеанса = ПолучитьПараметрСеанса(ИмяПараметраСеанса);
	//НовоеЗначение = БоР_ОбщийМодуль.ПолучитьНастройкуПользователя(Пользователь, ИмяНастройки);
	//Если ЗначениеЗаполнено(ЗначениеПараметраСеанса) Тогда
	//	Объект[ИмяРеквизита] = ЗначениеПараметраСеанса;
	//ИначеЕсли ЗначениеЗаполнено(НовоеЗначение) Тогда
	//	Объект[ИмяРеквизита] = НовоеЗначение;
	//Иначе
	//	Объект[ИмяРеквизита] = ЗначениеПоУмолчанию;
	//КонецЕсли;
КонецПроцедуры

Процедура ЗаполнитьОбъектДаннымиЗаполнения(Объект, ДанныеЗаполнения, НезаполняемыеДанные = Неопределено) Экспорт
	
	Если ТипЗнч(ДанныеЗаполнения) <> Тип("Структура") Тогда
		ВозВрат;
	КонецЕсли;
	
	ТипНезаполняемыхДанных = ТипЗнч(НезаполняемыеДанные);
	Если ТипНезаполняемыхДанных = Тип("Структура") Тогда
		СписокИсключаемыхСвойств = "";
		Для каждого ЭлементКоллекции Из НезаполняемыеДанные Цикл
			СписокИсключаемыхСвойств = ?(СписокИсключаемыхСвойств = "", "", ",") + ?(ЗначениеЗаполнено(ЭлементКоллекции.Значение), Строка(ЭлементКоллекции.Значение), ЭлементКоллекции.Ключ);
		КонецЦикла;
	ИначеЕсли ТипНезаполняемыхДанных = Тип("СписокЗначений") Тогда
		СписокИсключаемыхСвойств = "";
		Для каждого ЭлементКоллекции Из НезаполняемыеДанные Цикл
			СписокИсключаемыхСвойств = ?(СписокИсключаемыхСвойств = "", "", ",") + Строка(ЭлементКоллекции.Значение);
		КонецЦикла;
	ИначеЕсли ТипНезаполняемыхДанных = Тип("Массив") Тогда
		СписокИсключаемыхСвойств = "";
		Для каждого ЭлементКоллекции Из НезаполняемыеДанные Цикл
			СписокИсключаемыхСвойств = ?(СписокИсключаемыхСвойств = "", "", ",") + Строка(ЭлементКоллекции.Значение);
		КонецЦикла;
	ИначеЕсли ТипНезаполняемыхДанных = Тип("Строка") Тогда
		СписокИсключаемыхСвойств = НезаполняемыеДанные;
	Иначе
		СписокИсключаемыхСвойств = "";
	КонецЕсли;
	
	// БоР : Позже (если понадобится) привинтим сюда заполнение ТЧ и прочих "сложностей" 14.04.2013 18:35:58
	ЗаполнитьЗначенияСвойств(Объект, ДанныеЗаполнения, , СписокИсключаемыхСвойств);
	//++Krevpet 10 декабря 2015 г. 9:34:37 Задача №24159
	//Если ТипЗнч(Объект) = Тип("ДокументОбъект.ВыдачаПоРецептуМК") Тогда 
	//	Запрос = Новый Запрос("ВЫБРАТЬ
	//	|	РецептМКПродуктыПитания.МНН,
	//	|	РецептМКПродуктыПитания.Количество
	//	|ИЗ
	//	|	Документ.РецептМК.ПродуктыПитания КАК РецептМКПродуктыПитания
	//	|ГДЕ
	//	|	РецептМКПродуктыПитания.Ссылка = &Ссылка");
	//	Запрос.УстановитьПараметр("Ссылка",Объект.Рецепт);
	//	Объект.ТорговыеНаименования.Загрузить(Запрос.Выполнить().Выгрузить());
	//КонецЕсли;
	//--Krevpet 10 декабря 2015 г. 9:34:37 Задача №24159	
	
КонецПроцедуры

Функция ПолучитьПараметрСеанса(ИмяПараметраСеанса) Экспорт
	Если ИмяПараметраСеанса = Неопределено Тогда
		ВозВрат Неопределено;
	ИначеЕсли Метаданные.ПараметрыСеанса.Найти(ИмяПараметраСеанса) <> Неопределено Тогда
		ВозВрат ПараметрыСеанса[ИмяПараметраСеанса];
	Иначе
		ВозВрат Неопределено;
	КонецЕсли;
КонецФункции

Функция ЗаполнитьРеквизитыИзПараметров(Форма, Знач НезаполняемыеРеквизиты = Неопределено) Экспорт
	Если НезаполняемыеРеквизиты = Неопределено Тогда
		НезаполняемыеРеквизиты = Новый Массив;
	КонецЕсли;
	РеквизитыФормы = Форма.ПолучитьРеквизиты();
	Для каждого РеквизитФормы Из РеквизитыФормы Цикл
		Если НезаполняемыеРеквизиты.Найти(РеквизитФормы.Имя) = Неопределено И Форма.Параметры.Свойство(РеквизитФормы.Имя) Тогда
			Форма.Параметры.Свойство(РеквизитФормы.Имя, Форма[РеквизитФормы.Имя]);
		КонецЕсли;
	КонецЦикла;
КонецФункции

// БоР : Установка ссылки нового при необходимости и возврат 25.09.2016 14:12:39
Функция СоздатьИПолучитьСсылкуОбъекта(Объект) Экспорт
	Если Объект.ЭтоНовый() Тогда
		СсылкаНаОбъект = Объект.ПолучитьСсылкуНового();
		Если Не ЗначениеЗаполнено(СсылкаНаОбъект) Тогда
			СсылкаНаОбъект = Бор_ПовторноеИспользованиеСервер.МенеджерОбъектаПоПолномуИмени(Объект.Метаданные().ПолноеИмя()).ПолучитьСсылку();
		КонецЕсли;
		Объект.УстановитьСсылкуНового(СсылкаНаОбъект);
	Иначе
		СсылкаНаОбъект = Объект.Ссылка;
	КонецЕсли;
	ВозВрат СсылкаНаОбъект;
КонецФункции

#Область Короткие_вызовы_процедур_сообщения
// БоР : Сообщение пользователю и, при необходимости, запись в журнал регистрации 18.11.2012 21:49:59
Процедура СообщитьИЗаписатьВЖурнал(ИмяСобытия, ТекстСообщения, ВЖурнал = Истина, Сообщить = Истина, Знач УровеньЖурнала = Неопределено, ПривязкаСообщения = Неопределено) Экспорт
	Если УровеньЖурнала = Неопределено Тогда
		УровеньЖурнала = УровеньЖурналаРегистрации.Информация;
	КонецЕсли;
	Если Сообщить Тогда
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст 		= ТекстСообщения;
		ПривязатьСообщение(Сообщение, ПривязкаСообщения);
		Сообщение.Сообщить();
	КонецЕсли;
	Если ВЖурнал Тогда
		ЗаписьЖурналаРегистрации(ИмяСобытия, УровеньЖурнала, , ,ТекстСообщения);
	КонецЕсли;
КонецПроцедуры

// БоР : Привязка сообщения к полю, форме итд 18.11.2012 21:49:59
Процедура ПривязатьСообщение(Сообщение, ПривязкаСообщения) Экспорт
	Если ТипЗнч(ПривязкаСообщения) <> Тип("Структура") Тогда
		ВозВрат;
	КонецЕсли;
	Если ПривязкаСообщения.Свойство("Сообщение_Поле") И ПривязкаСообщения.Сообщение_Поле <> Неопределено Тогда
		Сообщение.Поле			= Строка(ПривязкаСообщения.Сообщение_Поле);
	КонецЕсли;
	Если ПривязкаСообщения.Свойство("Сообщение_ПутьКДанным") И ПривязкаСообщения.Сообщение_ПутьКДанным <> Неопределено Тогда
		Сообщение.ПутьКДанным	= Строка(ПривязкаСообщения.Сообщение_ПутьКДанным);
	КонецЕсли;
	Если ПривязкаСообщения.Свойство("Сообщение_УстановитьДанные") И ПривязкаСообщения.Сообщение_УстановитьДанные <> Неопределено Тогда
		Сообщение.УстановитьДанные(ПривязкаСообщения.Сообщение_УстановитьДанные);
	КонецЕсли;
	Если ПривязкаСообщения.Свойство("Сообщение_КлючДанных") И ПривязкаСообщения.Сообщение_КлючДанных <> Неопределено Тогда
		Сообщение.КлючДанных	= ПривязкаСообщения.Сообщение_КлючДанных;
	КонецЕсли;
	Если ПривязкаСообщения.Свойство("Сообщение_ИдентификаторНазначения") И ПривязкаСообщения.Сообщение_ИдентификаторНазначения <> Неопределено Тогда
		Сообщение.ИдентификаторНазначения	= ПривязкаСообщения.Сообщение_ИдентификаторНазначения;
	КонецЕсли;
КонецПроцедуры

Процедура СообщитьИЗаписатьВЖурналПоШаблону(ИмяСобытия, ШаблонСообщения, ПараметрыСообщения = Неопределено, ВЖурнал = Истина, Сообщить = Истина, Знач УровеньЖурнала = Неопределено) Экспорт
	ТекстСообщения	= СформироватьТекстСообщения(ШаблонСообщения, ПараметрыСообщения);
	ТекстИмяСобытия	= СформироватьТекстСообщения(ИмяСобытия, ПараметрыСообщения); // будем использовать тоже, как шаблон
	//Если ТипЗнч(ПараметрыСообщения) = Тип("Структура") Тогда
	//	Поле		= БоР_ОбщийМодульКлиентСервер.ПолучитьПолеСтруктуры(ПараметрыСообщения, "Сообщение_Поле");
	//	ПутьКДанным	= БоР_ОбщийМодульКлиентСервер.ПолучитьПолеСтруктуры(ПараметрыСообщения, "Сообщение_ПутьКДанным");
	//КонецЕсли;
	СообщитьИЗаписатьВЖурнал(ТекстИмяСобытия, ТекстСообщения, ВЖурнал, Сообщить, УровеньЖурнала, ПараметрыСообщения);
КонецПроцедуры

Процедура Сообщить_С(ШаблонСообщения, ПараметрыСообщения = Неопределено, Знач УровеньЖурнала = Неопределено) Экспорт // первый и третий параметры не нужны - оставлены для общности
	СообщитьИЗаписатьВЖурналПоШаблону("", ШаблонСообщения, ПараметрыСообщения, Ложь, Истина, УровеньЖурнала);
КонецПроцедуры

Процедура Сообщить_Ж(ИмяСобытия, ШаблонСообщения, ПараметрыСообщения = Неопределено, Знач УровеньЖурнала = Неопределено) Экспорт
	СообщитьИЗаписатьВЖурналПоШаблону(ИмяСобытия, ШаблонСообщения, ПараметрыСообщения, Истина, Ложь, УровеньЖурнала);
КонецПроцедуры

Процедура Сообщить_СЖ(ИмяСобытия, ШаблонСообщения, ПараметрыСообщения = Неопределено, Знач УровеньЖурнала = Неопределено) Экспорт
	СообщитьИЗаписатьВЖурналПоШаблону(ИмяСобытия, ШаблонСообщения, ПараметрыСообщения, Истина, Истина, УровеньЖурнала);
КонецПроцедуры

Процедура Сообщить_ЖО(ИмяСобытия, ШаблонСообщения, ПараметрыСообщения = Неопределено) Экспорт
	СообщитьИЗаписатьВЖурналПоШаблону(ИмяСобытия, ШаблонСообщения, ПараметрыСообщения, Истина, Ложь, УровеньЖурналаРегистрации.Ошибка);
КонецПроцедуры

Процедура Сообщить_СЖО(ИмяСобытия, ШаблонСообщения, ПараметрыСообщения = Неопределено) Экспорт
	СообщитьИЗаписатьВЖурналПоШаблону(ИмяСобытия, ШаблонСообщения, ПараметрыСообщения, Истина, Истина, УровеньЖурналаРегистрации.Ошибка);
КонецПроцедуры

Процедура Сообщить_ЖП(ИмяСобытия, ШаблонСообщения, ПараметрыСообщения = Неопределено) Экспорт
	СообщитьИЗаписатьВЖурналПоШаблону(ИмяСобытия, ШаблонСообщения, ПараметрыСообщения, Истина, Ложь, УровеньЖурналаРегистрации.Предупреждение);
КонецПроцедуры

Процедура Сообщить_СЖП(ИмяСобытия, ШаблонСообщения, ПараметрыСообщения = Неопределено) Экспорт
	СообщитьИЗаписатьВЖурналПоШаблону(ИмяСобытия, ШаблонСообщения, ПараметрыСообщения, Истина, Истина, УровеньЖурналаРегистрации.Предупреждение);
КонецПроцедуры
#КонецОбласти

#Область Отладочные_сообщения
////////////////////////////////////////////////////////////////////////////////////////
// БоР : Отладочные сообщения 27.07.2015 23:02:14
Процедура ОТЛАДКА(ИмяСобытия, ШаблонСообщения, ПараметрыСообщения = Неопределено, ВЖурнал = Истина, Сообщить = Истина, Знач УровеньЖурнала = Неопределено) Экспорт
	Если ПолучитьПараметрСеанса("Отладка") = Истина Тогда
		СообщитьИЗаписатьВЖурналПоШаблону(ИмяСобытия, ШаблонСообщения, ПараметрыСообщения, ВЖурнал, Сообщить, УровеньЖурнала);
	КонецЕсли;
КонецПроцедуры

Процедура ОТЛАДКА_Ж(ИмяСобытия, ШаблонСообщения, ПараметрыСообщения = Неопределено, Условие = Истина) Экспорт
	Если Условие = Истина Тогда
		ОТЛАДКА(ИмяСобытия, ШаблонСообщения, ПараметрыСообщения, Истина, Ложь, УровеньЖурналаРегистрации.Примечание);
	КонецЕсли;
КонецПроцедуры

Процедура ОТЛАДКА_С(ШаблонСообщения, ПараметрыСообщения = Неопределено, Условие = Истина) Экспорт
	Если Условие = Истина Тогда
		ОТЛАДКА("", ШаблонСообщения, ПараметрыСообщения, Ложь, Истина, УровеньЖурналаРегистрации.Примечание);
	КонецЕсли;
КонецПроцедуры

Процедура ОТЛАДКА_СЖ(ИмяСобытия, ШаблонСообщения, ПараметрыСообщения = Неопределено, Условие = Истина) Экспорт
	Если Условие = Истина Тогда
		ОТЛАДКА(ИмяСобытия, ШаблонСообщения, ПараметрыСообщения, Истина, Истина, УровеньЖурналаРегистрации.Примечание);
	КонецЕсли;
КонецПроцедуры
#КонецОбласти

#Область Еще_работа_с_сообщениями
// БоР : формирует текст по шаблону и подстановочным значениям, аналогично тексту ошибки в процедуре ВыводОшибок 18.03.2013 18:09:08
Функция СформироватьТекстСообщения(ШаблонСообщения, ЗначенияПараметров = Неопределено, ЗначенияПараметровПоИменам = Истина) Экспорт
	ТекстСообщения = ШаблонСообщения;
	ТекстСообщения = СтрЗаменить(ТекстСообщения, " &ПС ", Символы.ПС);
	ТекстСообщения = СтрЗаменить(ТекстСообщения, "&ПС", Символы.ПС);
	Если ЗначениеЗаполнено(ЗначенияПараметров) Тогда
		НомерПараметра = 0;
		Для каждого Параметр Из ЗначенияПараметров Цикл
			НомерПараметра = НомерПараметра + 1;
			Если ЗначенияПараметровПоИменам Тогда
				Если ТипЗнч(ЗначенияПараметров) = Тип("Структура") Тогда
					ИмяПараметра      = "&" + Параметр.Ключ;
					ЗначениеПараметра = Параметр.Значение;
				ИначеЕсли ТипЗнч(ЗначенияПараметров) = Тип("Соответствие") Тогда
					ИмяПараметра      = "&" + Параметр.Ключ;
					ЗначениеПараметра = Параметр.Значение;
				ИначеЕсли ТипЗнч(ЗначенияПараметров) = Тип("СписокЗначений") Тогда
					ИмяПараметра      = "&" + Параметр.Представление;
					ЗначениеПараметра = Параметр.Значение;
				КонецЕсли;
			Иначе
				ИмяПараметра      = "&" + Формат(НомерПараметра, "ЧЦ=2; ЧВН=");
				Если ТипЗнч(ЗначенияПараметров) = Тип("Структура") Тогда
					ЗначениеПараметра = Параметр.Значение;
				ИначеЕсли ТипЗнч(ЗначенияПараметров) = Тип("Соответствие") Тогда
					ЗначениеПараметра = Параметр.Значение;
				ИначеЕсли ТипЗнч(ЗначенияПараметров) = Тип("СписокЗначений") Тогда
					ЗначениеПараметра = Параметр.Значение;
				ИначеЕсли ТипЗнч(ЗначенияПараметров) = Тип("Массив") Тогда
					ЗначениеПараметра = Параметр;
				КонецЕсли;
			КонецЕсли;
			ТекстСообщения = СтрЗаменить(ТекстСообщения, ИмяПараметра, ЗначениеПараметра);
		КонецЦикла;
	КонецЕсли;
	ВозВрат ТекстСообщения;
КонецФункции

// БоР : Формирует строку со значениями через запятую или еще как. Не факт, что работает :) 06.06.2013 21:45:41
// БоР : Здоровая, сложная и наполовину неработающая процедура 06.06.2013 21:45:41
Функция СформироватьСтрокуИзЗначений(Знач КоллекцияЗначений, Разделитель = ",", ВыводитьИменаПолей = Истина, ЗаключатьВКавычки = Истина, РазделительИмениИЗначения = ":", ПропускатьПустыеЗначения = Ложь, ВключаемыеЭлементы = Неопределено, ИсключаемыеЭлементы = Неопределено) Экспорт
	
	КоллекцияДляОбхода = КоллекцияЗначений;
	Владелец = Неопределено;
	Если ТипЗнч(КоллекцияЗначений) = Тип("Массив") Тогда
		ВыражениеЗначения	= "Строка(ЭлементКоллекции)";
		ВыражениеИмени		= """Значение "" + ИндексЭлемента";
	ИначеЕсли ТипЗнч(КоллекцияЗначений) = Тип("ФиксированныйМассив") Тогда
		ВыражениеЗначения	= "Строка(ЭлементКоллекции)";
		ВыражениеИмени		= """Значение "" + ИндексЭлемента";
	ИначеЕсли ТипЗнч(КоллекцияЗначений) = Тип("СписокЗначений") Тогда
		ВыражениеЗначения	= "Строка(ЭлементКоллекции.Значение)";
		ВыражениеИмени		= "ЭлементКоллекции.Представление";
	ИначеЕсли ТипЗнч(КоллекцияЗначений) = Тип("Структура") Тогда
		ВыражениеЗначения	= "Строка(ЭлементКоллекции.Значение)";
		ВыражениеИмени		= "ЭлементКоллекции.Ключ";
	ИначеЕсли ТипЗнч(КоллекцияЗначений) = Тип("ФиксированнаяСтруктура") Тогда
		ВыражениеЗначения	= "Строка(ЭлементКоллекции.Значение)";
		ВыражениеИмени		= "ЭлементКоллекции.Ключ";
	#Если Сервер Тогда
	ИначеЕсли ТипЗнч(КоллекцияЗначений) = Тип("ТаблицаЗначений") Тогда
		ВыражениеЗначения	= "Строка(ЭлементКоллекции.Значение)";
		ВыражениеИмени		= "ЭлементКоллекции.Имя";
	ИначеЕсли ТипЗнч(КоллекцияЗначений) = Тип("СтрокаТаблицыЗначений") Тогда
		ВыражениеЗначения	= "Строка(ЭлементКоллекции[ИндексЭлемента])";
		ВыражениеИмени		= "Владелец.Колонки[ИндексЭлемента].Имя";
		Владелец			= КоллекцияЗначений.Владелец();
		КоллекцияДляОбхода	= Владелец.Колонки;
	ИначеЕсли ТипЗнч(КоллекцияЗначений) = Тип("ВыборкаИзРезультатаЗапроса") Тогда
		ВыражениеЗначения	= "Строка(ЭлементКоллекции[ИндексЭлемента])";
		ВыражениеИмени		= "Владелец.Колонки[ИндексЭлемента].Имя";
		Владелец			= КоллекцияЗначений.Владелец();
		КоллекцияДляОбхода	= Владелец.Колонки;
	#КонецЕсли	
	ИначеЕсли ТипЗнч(КоллекцияЗначений) = Тип("Соответствие") Тогда
		ВыражениеЗначения	= "Строка(ЭлементКоллекции.Значение)";
		ВыражениеИмени		= "Строка(ЭлементКоллекции.Ключ)";
	ИначеЕсли ТипЗнч(КоллекцияЗначений) = Тип("ФиксированноеСоответствие") Тогда
		ВыражениеЗначения	= "Строка(ЭлементКоллекции.Значение)";
		ВыражениеИмени		= "Строка(ЭлементКоллекции.Ключ)";
	КонецЕсли;
	
	Если ТипЗнч(ВключаемыеЭлементы) = Тип("Строка") Тогда
		СписокВключаемых = РазобратьСтрокуНаСлова(ВключаемыеЭлементы, Новый Структура("П1,П2",",",";"));
	ИначеЕсли ТипЗнч(ВключаемыеЭлементы) = Тип("СписокЗначений") Тогда
		СписокВключаемых = ВключаемыеЭлементы;
	ИначеЕсли ТипЗнч(ВключаемыеЭлементы) = Тип("Массив") Тогда
		СписокВключаемых = Новый СписокЗначений;
		СписокВключаемых.ЗагрузитьЗначения(ВключаемыеЭлементы);
	ИначеЕсли ТипЗнч(ВключаемыеЭлементы) = Тип("Структура") Тогда
		СписокВключаемых = Новый СписокЗначений;
		Для каждого ЭлементСтруктуры Из ВключаемыеЭлементы Цикл
			СписокВключаемых.Добавить(ЭлементСтруктуры.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Если ТипЗнч(ИсключаемыеЭлементы) = Тип("Строка") Тогда
		СписокИсключаемых = РазобратьСтрокуНаСлова(ИсключаемыеЭлементы, Новый Структура("П1,П2",",",";"));
	ИначеЕсли ТипЗнч(ИсключаемыеЭлементы) = Тип("СписокЗначений") Тогда
		СписокИсключаемых = ИсключаемыеЭлементы;
	ИначеЕсли ТипЗнч(ИсключаемыеЭлементы) = Тип("Массив") Тогда
		СписокИсключаемых = Новый СписокЗначений;
		СписокИсключаемых.ЗагрузитьЗначения(ИсключаемыеЭлементы);
	ИначеЕсли ТипЗнч(ИсключаемыеЭлементы) = Тип("Структура") Тогда
		СписокИсключаемых = Новый СписокЗначений;
		Для каждого ЭлементСтруктуры Из ИсключаемыеЭлементы Цикл
			СписокИсключаемых.Добавить(ЭлементСтруктуры.Значение);
		КонецЦикла;
	КонецЕсли;
	
	
	СтрокаТекста = "";
	ИндексЭлемента = 0;
	Для каждого ЭлементКоллекции Из КоллекцияЗначений Цикл
		Если ТипЗнч(КоллекцияЗначений) = Тип("СписокЗначений") Тогда
			ИндексЭлемента		= КоллекцияЗначений.Индекс(ЭлементКоллекции);
		#Если Сервер Тогда
		ИначеЕсли ТипЗнч(КоллекцияЗначений) = Тип("ТаблицаЗначений") Тогда
			ИндексЭлемента		= КоллекцияЗначений.Индекс(ЭлементКоллекции);
		#КонецЕсли	
		Иначе
			ИндексЭлемента = ИндексЭлемента + 1;
		КонецЕсли;
		ЗначениеЭлемента	= СокрЛП(Вычислить(ВыражениеЗначения));
		Если ПропускатьПустыеЗначения И Не ЗначениеЗаполнено(ЗначениеЭлемента) Тогда
			Продолжить;
		КонецЕсли;
		Если ЗаключатьВКавычки Тогда
			ЗначениеЭлемента = """" + ЗначениеЭлемента + """";
		КонецЕсли;
		Если ВыводитьИменаПолей ИЛИ ЗначениеЗаполнено(СписокВключаемых) ИЛИ ЗначениеЗаполнено(СписокИсключаемых) Тогда
			ИмяЭлемента			= СокрЛП(Вычислить(ВыражениеИмени));
		КонецЕсли;
		Если ЗначениеЗаполнено(СписокВключаемых) Тогда
			Если Не СписокВключаемых.НайтиПоЗначению(ИмяЭлемента) Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		Если ЗначениеЗаполнено(СписокИсключаемых) Тогда
			Если СписокИсключаемых.НайтиПоЗначению(ИмяЭлемента) Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		Если ВыводитьИменаПолей Тогда
			СтрокаЭлемента = ИмяЭлемента + РазделительИмениИЗначения + ЗначениеЭлемента;
		Иначе
			СтрокаЭлемента = ЗначениеЭлемента;
		КонецЕсли;
		СтрокаТекста = СтрокаТекста + ?(ЗначениеЗаполнено(СтрокаТекста), Разделитель, "") + СтрокаЭлемента;
	КонецЦикла; 
	ВозВрат СтрокаТекста;
КонецФункции
#КонецОбласти

#Область Ссылка_и_УникальныйИдентификатор
// БоР :  04.08.2013 4:20:08
Функция ПолучитьУИСсылки(Ссылка) Экспорт
	ВозВрат Ссылка.УникальныйИдентификатор();
КонецФункции

// БоР :  04.08.2013 4:20:08
Функция ПолучитьСсылкуПоУИ(МенеджерОбъекта, УникальныйИдентификатор) Экспорт
	Если ТипЗнч(УникальныйИдентификатор) = Тип("Строка") Тогда
		Попытка
			УИ = Новый УникальныйИдентификатор(УникальныйИдентификатор);
		Исключение
			ВозВрат Неопределено;
		КонецПопытки;
	ИначеЕсли ТипЗнч(УникальныйИдентификатор) = Тип("УникальныйИдентификатор") Тогда
		УИ = УникальныйИдентификатор;
	Иначе
		ВозВрат Неопределено;
	КонецЕсли;
	Попытка
		Ссылка = МенеджерОбъекта.ПолучитьСсылку(УИ);
	Исключение
		ВозВрат Неопределено;
	КонецПопытки;

	ВидОбъекта = ОбщегоНазначения.ВидОбъектаПоСсылке(МенеджерОбъекта.ПустаяСсылка());
	ИмяОбъекта = МенеджерОбъекта.ПустаяСсылка().Метаданные().Имя;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ТаблицаОбъекта.Ссылка
	|ИЗ
	|	Документ.Контракт КАК ТаблицаОбъекта
	|ГДЕ
	|	ТаблицаОбъекта.Ссылка = &Ссылка";
	
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "Документ.Контракт", ВидОбъекта + "." + ИмяОбъекта);
	
	Результат = Запрос.Выполнить();
	ВыборкаДетальныеЗаписи = Результат.Выбрать();
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		ВозВрат ВыборкаДетальныеЗаписи.Ссылка;
	КонецЦикла;
	
	ВозВрат Неопределено;
КонецФункции
#КонецОбласти

#Область Приведение_типов
// БоР : Преобразовывает значение в булево 06.04.2011 3:22:23
Функция ВБулево(ПочтиБулево) Экспорт
	ТипБулево = Новый ОписаниеТипов("Булево");
	Если ТипЗнч(ПочтиБулево) = Тип("Строка") И Не ЕстьНеЦифры(ПочтиБулево) Тогда
		ВозВрат ТипБулево.ПривестиЗначение(ВЧисло(ПочтиБулево));
	Иначе
		ВозВрат ТипБулево.ПривестиЗначение(ПочтиБулево);
	КонецЕсли;
КонецФункции // ВЧисло()

// БоР : Преобразовывает значение в число 11.01.2010 0:19:23
Функция ВЧисло(ПочтиЧисло) Экспорт
	ТипЧисло = Новый ОписаниеТипов("Число",Новый КвалификаторыЧисла(0, 0, ДопустимыйЗнак.Любой));
	ВозВрат ТипЧисло.ПривестиЗначение(ПочтиЧисло);
КонецФункции // ВЧисло()

// БоР : Преобразовывает значение в дату 11.01.2010 0:19:23
Функция ВДату(Знач ПочтиДата) Экспорт
	Если ТипЗнч(ПочтиДата) = Тип("СтандартнаяДатаНачала") Тогда
		ПочтиДата = ПочтиДата.Дата;
	КонецЕсли;
	ТипДата = Новый ОписаниеТипов("Дата", , ,Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя));
	ВозВрат ТипДата.ПривестиЗначение(ПочтиДата);
КонецФункции // ВДату()

// БоР : Преобразует дату из дд.мм.гггг в дату 1С 07.01.2007 21:04:47
Функция ДатаИзСтроки(Знач ДатаСтрокой, Разделители = ".", Знач ПорядокСоставляющих = "ДМГчмс", ГодНачалаСтолетия = "30") Экспорт
	ПорядокСоставляющих = СокрЛП(ПорядокСоставляющих);
	ДатаСтрокойБыла = ДатаСтрокой;
	Если ПустаяСтрока(ДатаСтрокой) Тогда
		ВозВрат '0001-01-01';
	КонецЕсли;
	Если ТипЗнч(Разделители) = Тип("Строка") Тогда
		ДатаСтрокой = СтрЗаменить(ДатаСтрокой,Разделители,Символы.ПС);
	ИначеЕсли ТипЗнч(Разделители) = Тип("СписокЗначений") Тогда
		Для каждого Разделитель Из Разделители Цикл
			ДатаСтрокой = СтрЗаменить(ДатаСтрокой,Разделитель.Значение,Символы.ПС);
		КонецЦикла;
	ИначеЕсли ТипЗнч(Разделители) = Тип("Структура") Тогда
		Для каждого Разделитель Из Разделители Цикл
			ДатаСтрокой = СтрЗаменить(ДатаСтрокой,Разделитель.Значение,Символы.ПС);
		КонецЦикла;
	ИначеЕсли ТипЗнч(Разделители) = Тип("Соответствие") Тогда
		Для каждого Разделитель Из Разделители Цикл
			ДатаСтрокой = СтрЗаменить(ДатаСтрокой,Разделитель.Значение,Символы.ПС);
		КонецЦикла;
	Иначе
		ВозВрат '0001-01-01';
	КонецЕсли;
	Если СтрЧислоСтрок(ДатаСтрокой)<3 Тогда
		ВозВрат '0001-01-01';
	КонецЕсли; 
	ПозицияД = Найти(ПорядокСоставляющих,"Д");
	ПозицияМ = Найти(ПорядокСоставляющих,"М");
	ПозицияГ = Найти(ПорядокСоставляющих,"Г");
	Позиция_ч = Найти(ПорядокСоставляющих,"ч");
	Позиция_м = Найти(ПорядокСоставляющих,"м");
	Позиция_с = Найти(ПорядокСоставляющих,"с");
	
	ПозицияД = ?(ПозицияД = 0,1,ПозицияД);
	ПозицияМ = ?(ПозицияМ = 0,2,ПозицияМ);
	ПозицияГ = ?(ПозицияГ = 0,3,ПозицияГ);
	
	День  = СтрПолучитьСтроку(ДатаСтрокой,ПозицияД);
	Месяц = СтрПолучитьСтроку(ДатаСтрокой,ПозицияМ);
	Год   = СтрПолучитьСтроку(ДатаСтрокой,ПозицияГ);
	
	Если СтрДлина(Год) = 2 Тогда
		Если Год < ГодНачалаСтолетия Тогда
			Год = "20" + Год;
		Иначе
			Год = "19" + Год;
		КонецЕсли;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Позиция_ч) Тогда
		Часов = СтрПолучитьСтроку(ДатаСтрокой,Позиция_ч);
	Иначе
		Часов = "0";
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Позиция_м) Тогда
		Минут = СтрПолучитьСтроку(ДатаСтрокой,Позиция_м);
	Иначе
		Минут = "0";
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Позиция_с) Тогда
		Секунд = СтрПолучитьСтроку(ДатаСтрокой,Позиция_с);
	Иначе
		Секунд = "0";
	КонецЕсли;
	
	Попытка
		ВозВрат Дата(Год, Месяц, День, Часов, Минут, Секунд);
	Исключение
		//СообщитьИЗаписатьВЛог("Ошибка при преобразовании значения в дату : """+ДатаСтрокойБыла+"""!");
	КонецПопытки;
	
КонецФункции // ДатаИзСтроки(ДатаСой)
#КонецОбласти

#Область Обработка_строк
// БоР : Список часто встречающихся разделителей 12.10.2016 21:32:27
Функция СписокРазделителей() Экспорт
	СписокРазделителей = Новый Массив;
	СписокРазделителей.Добавить(Символы.ПС);
	СписокРазделителей.Добавить(Символы.Таб);
	СписокРазделителей.Добавить(" ");
	СписокРазделителей.Добавить(".");
	СписокРазделителей.Добавить(",");
	СписокРазделителей.Добавить("<");
	СписокРазделителей.Добавить(">");
	СписокРазделителей.Добавить("?");
	СписокРазделителей.Добавить("\");
	СписокРазделителей.Добавить("|");
	СписокРазделителей.Добавить("/");
	СписокРазделителей.Добавить("*");
	СписокРазделителей.Добавить("-");
	СписокРазделителей.Добавить("+");
	СписокРазделителей.Добавить("""");
	СписокРазделителей.Добавить("'");
	СписокРазделителей.Добавить(";");
	СписокРазделителей.Добавить(":");
	СписокРазделителей.Добавить("~");
	СписокРазделителей.Добавить("!");
	СписокРазделителей.Добавить("@");
	СписокРазделителей.Добавить("#");
	СписокРазделителей.Добавить("$");
	СписокРазделителей.Добавить("%");
	СписокРазделителей.Добавить("^");
	СписокРазделителей.Добавить("(");
	СписокРазделителей.Добавить(")");
	СписокРазделителей.Добавить("=");
	СписокРазделителей.Добавить("&");
КонецФункции

// БоР : Разбирает одну строку на отдельныен слова в соответствии со списком разделителей  07.01.2007 1:20:05
Функция РазобратьСтрокуНаСлова(Знач СтрокаТекста, Знач Разделители, ОставлятьПустыеСтроки = Ложь) Экспорт
	Если ТипЗнч(Разделители) = Тип("Строка") Тогда
		СписокРазделителей = Новый Массив;
		СписокРазделителей.Добавить(Разделители);
	Иначе
		СписокРазделителей = Разделители;
	КонецЕсли;
	РазделителиЭтоМассив = ТипЗнч(СписокРазделителей) = Тип("Массив");
	Для каждого Разделитель Из СписокРазделителей Цикл
		ЗначениеРазделителя = ?(РазделителиЭтоМассив, Разделитель, Разделитель.Значение);
		СтрокаТекста=СтрЗаменить(СтрокаТекста, ЗначениеРазделителя, Символы.ПС);
	КонецЦикла; 
	СЗ = Новый СписокЗначений;
	Для Н = 1 По СтрЧислоСтрок(СтрокаТекста) Цикл
		ОчереднаяСтрока = СтрПолучитьСтроку(СтрокаТекста, Н);
		Если СокрЛП(ОчереднаяСтрока) <> "" ИЛИ ОставлятьПустыеСтроки Тогда
			СЗ.Добавить(СокрЛП(ОчереднаяСтрока));
		КонецЕсли;
	КонецЦикла;
	ВозВрат СЗ;
КонецФункции

// БоР : Функция проверяет наличие в строке только цифр 28.09.2008 18:16:27
Функция ЕстьНеЦифры(Знач СтрокаПроверки) Экспорт

	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Истина;
	КонецЕсли;
	
	СтрокаПроверки = СокрЛП(СтрокаПроверки);
	Длина = СтрДлина(СтрокаПроверки);
	
	Для а = 1 По Длина Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если (КодСимвола < 48) ИЛИ (КодСимвола > 57) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
	
КонецФункции
 
// БоР : Добавляет подстроку в строку (предположительно один символ). 02.09.2008 12:50:39
// БоР : может получиться строка длиннее заданной длины (если ДобавляемыйСимвол длиннее, чем один символ)
Функция ДобавитьСимволы(Знач СтрокаТекста, ДлинаРезультата, ДобавляемыйСимвол = " ", Слева = Истина, УбиратьСтарыеПробелы = Истина) Экспорт
	Если УбиратьСтарыеПробелы Тогда
		СтрокаТекста = СокрЛП(СтрокаТекста);
	КонецЕсли;
	ДлинаСтроки = СтрДлина(СтрокаТекста);
	Пока СтрДлина(СтрокаТекста) < ДлинаРезультата Цикл
		СтрокаТекста = ?(Слева,ДобавляемыйСимвол+СтрокаТекста,СтрокаТекста+ДобавляемыйСимвол);
	КонецЦикла;
	
	ВозВрат СтрокаТекста;
КонецФункции // ДобавитьСимволы()
#КонецОбласти

#Область Единицы_прописью
// БоР : Возвращает единицу измерения, другой предмет исчисления в нужном падеже 07.10.2010 22:11:19
Функция ЕдиницаПрописью(Знач Количество, Знач ФорматнаяСтрока) Экспорт
	// Напрмиер Количество = 10 - ответ - листов
	// 			Количество = 3  - ответ - листа
	// ФорматнаяСтрока например : "листа, листов, листов, м, , , , ,0"
	ВозВрат СтрЗаменить(ЧислоПрописью(ВЧисло(Количество), "НП=Истина, НД=Ложь", ФорматнаяСтрока),
						ЧислоПрописью(ВЧисло(Количество), "НП=Ложь  , НД=Ложь", " , , , , , , , ,0"),
	                    "");
КонецФункции
 
// БоР : Возвращает единицу измерения, другой предмет исчисления в нужном падеже 07.10.2010 22:11:19
Функция РублиПрописью(Знач Сумма) Экспорт
	ВозВрат ЧислоПрописью(ВЧисло(Сумма), "НП=Истина, НД=Ложь", "рубль, рубля, рублей, м, копейка, копейки, копеек, ж, 2");
КонецФункции
#КонецОбласти

#Область Читы_Присвоить_Выполнить_Вычислить
// БоР : Присваивает из одной переменной в другую 25.05.2009 5:31:38
Функция Присвоить(Куда, Что) Экспорт
	Куда = Что;
	ВозВрат Куда;
КонецФункции // Присвоить(Куда, Что)

// БоР : Выполняет кусок кода 25.05.2009 5:31:38
Функция ВыполнитьКод(Что) Экспорт
	Выполнить(Что);
	ВозВрат Истина;
КонецФункции

// БоР : Вычисляет выражение. Можно использовать например при COM-соединении 25.05.2009 5:31:38
Функция ВычислитьВыражение(Что) Экспорт
	ВозВрат Вычислить(Что);
КонецФункции
#КонецОбласти

#Область ТЗ_и_ДЗ
// БоР : Загружает из табличного документ таблицу значений 08.10.2010 2:22:35
Функция ПрочитатьТабличныйДокументВТЗ(Источник) Экспорт
	Построитель = Новый ПостроительЗапроса;
	Построитель.ИсточникДанных = Новый ОписаниеИсточникаДанных(Источник.Область(1,1,Источник.ВысотаТаблицы,Источник.ШиринаТаблицы));
	Построитель.ЗаполнитьНастройки();
	Построитель.Выполнить();
	ВозВрат Построитель.Результат.Выгрузить();
КонецФункции // ПрочитатьТабличныйДокументВТЗ()

// БоР : Добавляет колонку В ТЗ или ДЗ, если ее там нет 07.02.2010 16:31:27
Функция ДобавитьКолонкуВТЗ(ТаблицаЗначений, ИмяКолонки, ТипКолонки = Неопределено, Заголовок = "", Ширина = 0, НомерКолонки = 0) Экспорт
	Если ТаблицаЗначений.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
		ТаблицаЗначений.Колонки.Вставить(?(НомерКолонки <= 0, ТаблицаЗначений.Колонки.Количество(), НомерКолонки - 1), ИмяКолонки, ТипКолонки, Заголовок, Ширина);
	КонецЕсли;
КонецФункции // ДобавитьКолонкуВТЗ()

// БоР :  24.03.2015 14:47:42
Функция ПреобразоватьСтрокуТЗВСтруктуру(СтрокаТЗ) Экспорт
	СтруктураТЗ = Новый Структура;
	КолонкиТЗ = СтрокаТЗ.Владелец().Колонки;
	Для каждого Колонка Из КолонкиТЗ Цикл
		СтруктураТЗ.Вставить(Колонка.Имя, СтрокаТЗ[Колонка.Имя]);
	КонецЦикла;
	ВозВрат СтруктураТЗ;
КонецФункции

// БоР : Добавляет в таблицу колонку с номером строки (как в ТЧ итп) 08.02.2016 3:27:18
Процедура ПронумероватьТЗ(ТЗ, ИмяКолонки = "НомерСтроки") Экспорт
	
	Если ТипЗнч(ТЗ) <> Тип("ТаблицаЗначений") Тогда
		ВозВрат;
	КонецЕсли;
	Если Ложь Тогда
		ТЗ = Новый ТаблицаЗначений;
	КонецЕсли;
	Если ТЗ.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
		ТЗ.Колонки.Добавить(ИмяКолонки, Новый ОписаниеТипов("Число"));
	КонецЕсли;
	Для каждого СтрокаТЗ Из ТЗ Цикл
		СтрокаТЗ[ИмяКолонки] = ТЗ.Индекс(СтрокаТЗ) + 1;
	КонецЦикла;
		
КонецПроцедуры

#Область Копирование_ДЗ_и_ТЗ_Написано_давно_Не_проверено_толком

// БоР : Добавляет из одной ТЗ в другую строки 02.11.2016 16:48:14
Процедура ДобавитьВТаблицуЗначений(ТЗПриемник, ТЗИсточник, ОтборСтрокИсточника = Неопределено, УдалятьИсходныеСтроки = Ложь) Экспорт

	Если ТЗПриемник = Неопределено Тогда
		ТЗПриемник = ТЗИсточник.СкопироватьКолонки();
	КонецЕсли;
	Если ОтборСтрокИсточника <> Неопределено Тогда
		СтрокиИсточника = ТЗИсточник.НайтиСтроки(ОтборСтрокИсточника);
	Иначе
		СтрокиИсточника = ТЗИсточник;
	КонецЕсли;
	Для каждого СтрокаТаблицыИсточника Из СтрокиИсточника Цикл
		СтрокаТаблицыПриемника = ТЗПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника);
	КонецЦикла;
	Если УдалятьИсходныеСтроки Тогда
		Если ОтборСтрокИсточника <> Неопределено Тогда
			Для каждого СтрокаКУдалению Из СтрокиИсточника Цикл
				ТЗИсточник.Удалить(СтрокаКУдалению);
			КонецЦикла;
		Иначе
			ТЗИсточник.Очистить();
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

Функция ПеренестиСтрокиТЗ(ТЗИсточник, ТЗПриемник, ОтборСтрок) Экспорт
	МассивКУдалению = ТЗИсточник.НайтиСтроки(ОтборСтрок);
	Если ТЗПриемник = Неопределено Тогда
		ТЗПриемник = ТЗИсточник.СкопироватьКолонки();
	КонецЕсли;
	Для каждого СтрокаТЗ Из МассивКУдалению Цикл
		СтрокаТЗПриемник = ТЗПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТЗПриемник, СтрокаТЗ);
	КонецЦикла;
	Для каждого СтрокаКУдалению Из МассивКУдалению Цикл
		ТЗИсточник.Удалить(СтрокаКУдалению);
	КонецЦикла;
	ВозВрат ТЗПриемник;
КонецФункции

// БоР : Копирует структуру ДЗ в ТЗ 04.03.2010 13:38:06
Функция СкопироватьСтруктуруДЗвТЗ(ТЗ = Неопределено, Источник, Знач КопируемыеКолонки = "", Знач ИсключаемыеКолонки = "", ОчищатьКолонки = Ложь) Экспорт
	
	Если ТЗ = Неопределено Тогда
		ТЗ = Новый ТаблицаЗначений;
	КонецЕсли;
	Если ТипЗнч(Источник) = Тип("ДеревоЗначений") Тогда
		КолонкиИсточника = Источник.Колонки;
	ИначеЕсли ТипЗнч(Источник) = Тип("КоллекцияСтрокДереваЗначений") Тогда
		Если Источник.Строки.Количество() = 0 Тогда
			ВремСтрока = Источник.Добавить();
			КолонкиИсточника = ВремСтрока.Владелец();
			Источник.Удалить(ВремСтрока);
		Иначе
			КолонкиИсточника = Источник.Получить(0).Владелец();
		КонецЕсли;
	ИначеЕсли ТипЗнч(Источник) = Тип("СтрокаДереваЗначений") Тогда
		КолонкиИсточника = Источник.Владелец().Колонки;
	КонецЕсли;
	Если ОчищатьКолонки Тогда
		ТЗ.Колонки.Очистить();
	КонецЕсли;
	Если ТипЗнч(ИсключаемыеКолонки) = Тип("Строка") Тогда
		ИсключаемыеКолонки = РазобратьСтрокуНаСлова(ИсключаемыеКолонки, ",");
	КонецЕсли;
	Если ТипЗнч(КопируемыеКолонки) = Тип("Строка") Тогда
		КопируемыеКолонки = РазобратьСтрокуНаСлова(КопируемыеКолонки, ",");
	КонецЕсли;
	Для каждого Колонка Из КолонкиИсточника Цикл
		Если ТипЗнч(ИсключаемыеКолонки) = Тип("Структура") И ИсключаемыеКолонки.Количество() > 0 И ИсключаемыеКолонки.Свойство(Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли;
		Если ТипЗнч(ИсключаемыеКолонки) = Тип("СписокЗначений") И ИсключаемыеКолонки.Количество() > 0 И ИсключаемыеКолонки.НайтиПоЗначению(Колонка.Имя) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Если ТипЗнч(КопируемыеКолонки) = Тип("Структура") И КопируемыеКолонки.Количество() > 0 И Не КопируемыеКолонки.Свойство(Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли;
		Если ТипЗнч(КопируемыеКолонки) = Тип("СписокЗначений") И КопируемыеКолонки.Количество() > 0 И КопируемыеКолонки.НайтиПоЗначению(Колонка.Имя) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ДобавитьКолонкуВТЗ(ТЗ, Колонка.Имя, Колонка.ТипЗначения, Колонка.Заголовок, Колонка.Ширина, КолонкиИсточника.Индекс(Колонка) + 1);
	КонецЦикла;
	
	ВозВрат ТЗ;
	
КонецФункции // СкопироватьСтруктуруДЗвТЗ(ДЗ,ТЗ, СписокКолонок, СписокИсключаемыхКолонок)

// БоР : Копирует структуру Выборки из запроса в ТЗ 12.10.2016 22:25:19
Функция СкопироватьСтруктуруВыборкиВ_ТЗ(ТЗ = Неопределено, Источник, Знач КопируемыеКолонки = "", Знач ИсключаемыеКолонки = "", ОчищатьКолонки = Ложь) Экспорт
	
	Если ТЗ = Неопределено Тогда
		ТЗ = Новый ТаблицаЗначений;
	КонецЕсли;
	КолонкиИсточника = Источник.Владелец().Колонки;
	Если ОчищатьКолонки Тогда
		ТЗ.Колонки.Очистить();
	КонецЕсли;
	Если ТипЗнч(ИсключаемыеКолонки) = Тип("Строка") Тогда
		ИсключаемыеКолонки = РазобратьСтрокуНаСлова(ИсключаемыеКолонки, ",");
	КонецЕсли;
	Если ТипЗнч(КопируемыеКолонки) = Тип("Строка") Тогда
		КопируемыеКолонки = РазобратьСтрокуНаСлова(КопируемыеКолонки, ",");
	КонецЕсли;
	Для каждого Колонка Из КолонкиИсточника Цикл
		Если ТипЗнч(ИсключаемыеКолонки) = Тип("Структура") И ИсключаемыеКолонки.Количество() > 0 И ИсключаемыеКолонки.Свойство(Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли;
		Если ТипЗнч(ИсключаемыеКолонки) = Тип("СписокЗначений") И ИсключаемыеКолонки.Количество() > 0 И ИсключаемыеКолонки.НайтиПоЗначению(Колонка.Имя) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Если ТипЗнч(КопируемыеКолонки) = Тип("Структура") И КопируемыеКолонки.Количество() > 0 И Не КопируемыеКолонки.Свойство(Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли;
		Если ТипЗнч(КопируемыеКолонки) = Тип("СписокЗначений") И КопируемыеКолонки.Количество() > 0 И КопируемыеКолонки.НайтиПоЗначению(Колонка.Имя) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ДобавитьКолонкуВТЗ(ТЗ, Колонка.Имя, Колонка.ТипЗначения, Колонка.Имя, Колонка.Ширина, КолонкиИсточника.Индекс(Колонка) + 1);
	КонецЦикла;
	
	ВозВрат ТЗ;
	
КонецФункции // СкопироватьСтруктуруДЗвТЗ(ДЗ,ТЗ, СписокКолонок, СписокИсключаемыхКолонок)

// БоР : Копирует структуру ТЗ в ДЗ 04.03.2010 13:38:06
Функция СкопироватьСтруктуруТЗвДЗ(ДЗ = Неопределено, Источник, Знач КопируемыеКолонки = "", Знач ИсключаемыеКолонки = "", ОчищатьКолонки = Ложь) Экспорт
	
	Если ДЗ = Неопределено Тогда
		ДЗ = Новый ДеревоЗначений;
	КонецЕсли;
	КолонкиИсточника = Источник.Колонки;
	Если ОчищатьКолонки Тогда
		ДЗ.Колонки.Очистить();
	КонецЕсли;
	Если ТипЗнч(ИсключаемыеКолонки) = Тип("Строка") Тогда
		ИсключаемыеКолонки = РазобратьСтрокуНаСлова(ИсключаемыеКолонки, ",");
	КонецЕсли;
	Если ТипЗнч(КопируемыеКолонки) = Тип("Строка") Тогда
		КопируемыеКолонки = РазобратьСтрокуНаСлова(КопируемыеКолонки, ",");
	КонецЕсли;
	Для каждого Колонка Из КолонкиИсточника Цикл
		Если ТипЗнч(ИсключаемыеКолонки) = Тип("Структура") И ИсключаемыеКолонки.Количество() > 0 И ИсключаемыеКолонки.Свойство(Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли;
		Если ТипЗнч(ИсключаемыеКолонки) = Тип("СписокЗначений") И ИсключаемыеКолонки.Количество() > 0 И ИсключаемыеКолонки.НайтиПоЗначению(Колонка.Имя) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Если ТипЗнч(КопируемыеКолонки) = Тип("Структура") И КопируемыеКолонки.Количество() > 0 И Не КопируемыеКолонки.Свойство(Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли;
		Если ТипЗнч(КопируемыеКолонки) = Тип("СписокЗначений") И КопируемыеКолонки.Количество() > 0 И КопируемыеКолонки.НайтиПоЗначению(Колонка.Имя) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ДобавитьКолонкуВТЗ(ДЗ, Колонка.Имя, Колонка.ТипЗначения, Колонка.Заголовок, Колонка.Ширина, КолонкиИсточника.Индекс(Колонка) + 1);
	КонецЦикла;
	
	ВозВрат ДЗ;
	
КонецФункции // СкопироватьСтруктуруТЗвДЗ(ТЗ, ДЗ, СписокКолонок, СписокИсключаемыхКолонок)

// БоР : Копирует структуру ДЗ в ДЗ 04.03.2010 13:38:06
Функция СкопироватьСтруктуруДЗвДЗ(ДЗ = Неопределено, Источник, Знач КопируемыеКолонки = "", Знач ИсключаемыеКолонки = "", ОчищатьКолонки = Ложь) Экспорт
	
	Если ДЗ = Неопределено Тогда
		ДЗ = Новый ДеревоЗначений;
	КонецЕсли;
	Если ТипЗнч(Источник) = Тип("ДеревоЗначений") Тогда
		КолонкиИсточника = Источник.Колонки;
	ИначеЕсли ТипЗнч(Источник) = Тип("КоллекцияСтрокДереваЗначений") Тогда
		Если Источник.Строки.Количество() = 0 Тогда
			ВремСтрока = Источник.Добавить();
			КолонкиИсточника = ВремСтрока.Владелец();
			Источник.Удалить(ВремСтрока);
		Иначе
			КолонкиИсточника = Источник.Получить(0).Владелец();
		КонецЕсли;
	ИначеЕсли ТипЗнч(Источник) = Тип("СтрокаДереваЗначений") Тогда
		КолонкиИсточника = Источник.Владелец().Колонки;
	КонецЕсли;
	Если ОчищатьКолонки Тогда
		ДЗ.Колонки.Очистить();
	КонецЕсли;
	Если ТипЗнч(ИсключаемыеКолонки) = Тип("Строка") Тогда
		ИсключаемыеКолонки = РазобратьСтрокуНаСлова(ИсключаемыеКолонки, ",");
	КонецЕсли;
	Если ТипЗнч(КопируемыеКолонки) = Тип("Строка") Тогда
		КопируемыеКолонки = РазобратьСтрокуНаСлова(КопируемыеКолонки, ",");
	КонецЕсли;
	Для каждого Колонка Из КолонкиИсточника Цикл
		Если ТипЗнч(ИсключаемыеКолонки) = Тип("Структура") И ИсключаемыеКолонки.Количество() > 0 И ИсключаемыеКолонки.Свойство(Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли;
		Если ТипЗнч(ИсключаемыеКолонки) = Тип("СписокЗначений") И ИсключаемыеКолонки.Количество() > 0 И ИсключаемыеКолонки.НайтиПоЗначению(Колонка.Имя) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Если ТипЗнч(КопируемыеКолонки) = Тип("Структура") И КопируемыеКолонки.Количество() > 0 И Не КопируемыеКолонки.Свойство(Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли;
		Если ТипЗнч(КопируемыеКолонки) = Тип("СписокЗначений") И КопируемыеКолонки.Количество() > 0 И КопируемыеКолонки.НайтиПоЗначению(Колонка.Имя) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ДобавитьКолонкуВТЗ(ДЗ, Колонка.Имя, Колонка.ТипЗначения, Колонка.Заголовок, Колонка.Ширина, КолонкиИсточника.Индекс(Колонка) + 1);
	КонецЦикла;
	
	ВозВрат ДЗ;
	
КонецФункции // СкопироватьСтруктуруТЗвДЗ(ТЗ, ДЗ, СписокКолонок, СписокИсключаемыхКолонок)

// БоР : Копирует содержимое строк ДЗ в ТЗ (без вложенных) 04.03.2010 13:38:06
Функция СкопироватьДЗвТЗ(ТЗ = Неопределено, Источник, Знач КопируемыеКолонки = "", Знач ИсключаемыеКолонки = "", ОчищатьСтроки = Ложь) Экспорт
	
	Если ТЗ = Неопределено Тогда
		ТЗ = СкопироватьСтруктуруТЗвДЗ(Неопределено, Источник, КопируемыеКолонки, ИсключаемыеКолонки, Ложь);
	КонецЕсли;
	
	Если ТипЗнч(Источник) = Тип("ДеревоЗначений") Тогда
		ДЗИсточник = Источник.Строки;
	ИначеЕсли ТипЗнч(Источник) = Тип("КоллекцияСтрокДереваЗначений") Тогда
		ДЗИсточник = Источник;
	ИначеЕсли ТипЗнч(Источник) = Тип("СтрокаДереваЗначений") Тогда
		ДЗИсточник = Источник.Строки;
	КонецЕсли;
	Если ОчищатьСтроки Тогда
		ТЗ.Очистить();
	КонецЕсли;

	ЗаполняемыеКолонки = СоздатьСтрокуКолонок(КопируемыеКолонки);
	ИсключаемыеКолонки = СоздатьСтрокуКолонок(ИсключаемыеКолонки);
	КопируемыеКолонки = ВычестьСписокКолонок(КопируемыеКолонки, ИсключаемыеКолонки);
	
	Если Не ЗначениеЗаполнено(ИсключаемыеКолонки) Тогда
		ИсключаемыеКолонки = Неопределено;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(КопируемыеКолонки) Тогда
		КопируемыеКолонки = Неопределено;
	КонецЕсли;
	Для каждого ИсходнаяСтрока Из ДЗИсточник Цикл
		НоваяСтрока = ТЗ.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, ИсходнаяСтрока, КопируемыеКолонки, ИсключаемыеКолонки);
	КонецЦикла;
	ВозВрат ТЗ;
	
КонецФункции // СкопироватьСтруктуруДЗвТЗ(ДЗ,ТЗ, СписокКолонок, СписокИсключаемыхКолонок)

// БоР : Копирует содержимое строк ДЗ в ДЗ (с вложенными) 04.03.2010 13:38:06
Функция СкопироватьДЗвДЗ(ДЗ = Неопределено, Источник, Знач КопируемыеКолонки = "", Знач ИсключаемыеКолонки = "", ОчищатьСтроки = Ложь) Экспорт
	
	Если ДЗ = Неопределено Тогда
		ДЗ = СкопироватьСтруктуруДЗвДЗ(Неопределено, Источник, КопируемыеКолонки, ИсключаемыеКолонки);
	КонецЕсли;
	
	Если ТипЗнч(Источник) = Тип("ДеревоЗначений") Тогда
		ДЗИсточник = Источник.Строки;
	ИначеЕсли ТипЗнч(Источник) = Тип("КоллекцияСтрокДереваЗначений") Тогда
		ДЗИсточник = Источник;
	ИначеЕсли ТипЗнч(Источник) = Тип("СтрокаДереваЗначений") Тогда
		ДЗИсточник = Источник.Строки;
	КонецЕсли;
	Если ТипЗнч(ДЗ) = Тип("ДеревоЗначений") Тогда
		ДЗПриемник = ДЗ.Строки;
	ИначеЕсли ТипЗнч(ДЗ) = Тип("КоллекцияСтрокДереваЗначений") Тогда
		ДЗПриемник = ДЗ;
	ИначеЕсли ТипЗнч(ДЗ) = Тип("СтрокаДереваЗначений") Тогда
		ДЗПриемник = ДЗ.Строки;
	КонецЕсли;
	Если ОчищатьСтроки Тогда
		ДЗПриемник.Очистить();
	КонецЕсли;

	ЗаполняемыеКолонки = СоздатьСтрокуКолонок(КопируемыеКолонки);
	ИсключаемыеКолонки = СоздатьСтрокуКолонок(ИсключаемыеКолонки);
	КопируемыеКолонки = ВычестьСписокКолонок(КопируемыеКолонки, ИсключаемыеКолонки);
	
	Если Не ЗначениеЗаполнено(ИсключаемыеКолонки) Тогда
		ИсключаемыеКолонки = Неопределено;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(КопируемыеКолонки) Тогда
		КопируемыеКолонки = Неопределено;
	КонецЕсли;
	Для каждого ИсходнаяСтрока Из ДЗИсточник Цикл
		НоваяСтрока = ДЗПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, ИсходнаяСтрока, КопируемыеКолонки, ИсключаемыеКолонки);
		Если ИсходнаяСтрока.Строки.Количество() > 0 Тогда
			СкопироватьДЗвДЗ(НоваяСтрока, ИсходнаяСтрока, КопируемыеКолонки, ИсключаемыеКолонки, ОчищатьСтроки);
		КонецЕсли;
	КонецЦикла;
	ВозВрат ДЗ;
	
КонецФункции // СкопироватьСтруктуруДЗвТЗ(ДЗ,ТЗ, СписокКолонок, СписокИсключаемыхКолонок)

//// БоР : Копирует содержимое всех строк ДЗ в ДЗ (с вложенными) 04.03.2010 13:38:06
//Функция СкопироватьСтрокиДЗ(ДЗ = Неопределено, Источник, Знач КопируемыеКолонки = "", Знач ИсключаемыеКолонки = "", ОчищатьСтроки = Ложь) Экспорт
//	
//	Если ДЗ = Неопределено Тогда
//		ДЗ = СкопироватьСтруктуруДЗвДЗ(Неопределено, Источник, КопируемыеКолонки, ИсключаемыеКолонки);
//	КонецЕсли;
//	
//	Если ТипЗнч(Источник) = Тип("ДеревоЗначений") Тогда
//		ДЗИсточник = Источник.Строки;
//	ИначеЕсли ТипЗнч(Источник) = Тип("КоллекцияСтрокДереваЗначений") Тогда
//		ДЗИсточник = Источник;
//	ИначеЕсли ТипЗнч(Источник) = Тип("СтрокаДереваЗначений") Тогда
//		ДЗИсточник = Источник.Строки;
//	КонецЕсли;
//	Если ТипЗнч(ДЗ) = Тип("ДеревоЗначений") Тогда
//		ДЗПриемник = ДЗ.Строки;
//	ИначеЕсли ТипЗнч(ДЗ) = Тип("КоллекцияСтрокДереваЗначений") Тогда
//		ДЗПриемник = ДЗ;
//	ИначеЕсли ТипЗнч(ДЗ) = Тип("СтрокаДереваЗначений") Тогда
//		ДЗПриемник = ДЗ.Строки;
//	КонецЕсли;
//	Если ОчищатьСтроки Тогда
//		ДЗПриемник.Очистить();
//	КонецЕсли;

//	ЗаполняемыеКолонки = СоздатьСтрокуКолонок(КопируемыеКолонки);
//	ИсключаемыеКолонки = СоздатьСтрокуКолонок(ИсключаемыеКолонки);
//	КопируемыеКолонки = ВычестьСписокКолонок(КопируемыеКолонки, ИсключаемыеКолонки);
//	
//	Если Не ЗначениеЗаполнено(ИсключаемыеКолонки) Тогда
//		ИсключаемыеКолонки = Неопределено;
//	КонецЕсли;
//	Если Не ЗначениеЗаполнено(КопируемыеКолонки) Тогда
//		КопируемыеКолонки = Неопределено;
//	КонецЕсли;
//	Для каждого ИсходнаяСтрока Из ДЗИсточник Цикл
//		НоваяСтрока = ДЗПриемник.Добавить();
//		ЗаполнитьЗначенияСвойств(НоваяСтрока, ИсходнаяСтрока, КопируемыеКолонки, ИсключаемыеКолонки);
//	КонецЦикла;
//	ВозВрат ДЗ;
//	
//КонецФункции // СкопироватьСтруктуруДЗвТЗ(ДЗ,ТЗ, СписокКолонок, СписокИсключаемыхКолонок)

// БоР : Копирует содержимое ТЗ в ДЗ 04.03.2010 13:38:06
Функция СкопироватьТЗвДЗ(ДЗ = Неопределено, Источник, Знач КопируемыеКолонки = "", Знач ИсключаемыеКолонки = "", ОчищатьСтроки = Ложь) Экспорт
	
	Если ДЗ = Неопределено Тогда
		ДЗ = СкопироватьСтруктуруТЗвДЗ(Неопределено, Источник, КопируемыеКолонки, ИсключаемыеКолонки, Ложь);
	КонецЕсли;
	
	Если ТипЗнч(ДЗ) = Тип("ДеревоЗначений") Тогда
		ДЗПриемник = ДЗ.Строки;
	ИначеЕсли ТипЗнч(ДЗ) = Тип("КоллекцияСтрокДереваЗначений") Тогда
		ДЗПриемник = ДЗ;
	ИначеЕсли ТипЗнч(ДЗ) = Тип("СтрокаДереваЗначений") Тогда
		ДЗПриемник = ДЗ.Строки;
	КонецЕсли;
	Если ОчищатьСтроки Тогда
		ДЗПриемник.Очистить();
	КонецЕсли;
	
	ЗаполняемыеКолонки = СоздатьСтрокуКолонок(КопируемыеКолонки);
	ИсключаемыеКолонки = СоздатьСтрокуКолонок(ИсключаемыеКолонки);
	КопируемыеКолонки = ВычестьСписокКолонок(КопируемыеКолонки, ИсключаемыеКолонки);
	
	Если Не ЗначениеЗаполнено(ИсключаемыеКолонки) Тогда
		ИсключаемыеКолонки = Неопределено;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(КопируемыеКолонки) Тогда
		КопируемыеКолонки = Неопределено;
	КонецЕсли;
	Для каждого ИсходнаяСтрока Из Источник Цикл
		НоваяСтрока = ДЗПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, ИсходнаяСтрока, КопируемыеКолонки, ИсключаемыеКолонки);
	КонецЦикла;
	ВозВрат ДЗ;
КонецФункции // СкопироватьСтруктуруДЗвТЗ(ДЗ,ТЗ, СписокКолонок, СписокИсключаемыхКолонок)

// БоР : Копирует содержимое строк Выборки из запроса в ТЗ (без вложенных) 12.10.2016 22:25:49
Функция СкопироватьВыборкуВ_ТЗ(ТЗ, Источник, Знач КопируемыеКолонки = "", Знач ИсключаемыеКолонки = "", ОчищатьСтроки = Ложь) Экспорт
	
	Если ТЗ = Неопределено Тогда
		ТЗ = СкопироватьСтруктуруВыборкиВ_ТЗ(Неопределено, Источник, КопируемыеКолонки, ИсключаемыеКолонки, Ложь);
	КонецЕсли;
	
	Если ОчищатьСтроки Тогда
		ТЗ.Очистить();
	КонецЕсли;

	ЗаполняемыеКолонки = СоздатьСтрокуКолонок(КопируемыеКолонки);
	ИсключаемыеКолонки = СоздатьСтрокуКолонок(ИсключаемыеКолонки);
	КопируемыеКолонки = ВычестьСписокКолонок(КопируемыеКолонки, ИсключаемыеКолонки);
	
	Если Не ЗначениеЗаполнено(ИсключаемыеКолонки) Тогда
		ИсключаемыеКолонки = Неопределено;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(КопируемыеКолонки) Тогда
		КопируемыеКолонки = Неопределено;
	КонецЕсли;
	Пока Источник.Следующий() Цикл
		НоваяСтрока = ТЗ.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Источник, КопируемыеКолонки, ИсключаемыеКолонки);
	КонецЦикла;
	ВозВрат ТЗ;
	
КонецФункции // СкопироватьСтруктуруДЗвТЗ(ДЗ,ТЗ, СписокКолонок, СписокИсключаемыхКолонок)

// БоР : заполняет колонку (или несколько) в ДЗ каким-либо значением 04.03.2010 13:38:06
Функция ЗаполнитьКолонкиДЗ(ДЗ, Знач ЗаполняемыеКолонки = "", Знач ИсключаемыеКолонки = "", Значение) Экспорт
	
	Если ТипЗнч(ДЗ) = Тип("ДеревоЗначений") Тогда
		ДЗПриемник = ДЗ.Строки;
	ИначеЕсли ТипЗнч(ДЗ) = Тип("КоллекцияСтрокДереваЗначений") Тогда
		ДЗПриемник = ДЗ;
	ИначеЕсли ТипЗнч(ДЗ) = Тип("СтрокаДереваЗначений") Тогда
		ДЗПриемник = ДЗ.Строки;
	КонецЕсли;
	
	ЗаполняемыеКолонки = СоздатьСтрокуКолонок(ЗаполняемыеКолонки);
	ИсключаемыеКолонки = СоздатьСтрокуКолонок(ИсключаемыеКолонки);
	ЗаполняемыеКолонки = ВычестьСписокКолонок(ЗаполняемыеКолонки, ИсключаемыеКолонки);
	
	Если Не ЗначениеЗаполнено(ИсключаемыеКолонки) Тогда
		ИсключаемыеКолонки = Неопределено;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(ЗаполняемыеКолонки) Тогда
		ЗаполняемыеКолонки = Неопределено;
	КонецЕсли;
	СписокКолонок = РазобратьСтрокуНаСлова(ЗаполняемыеКолонки, ",");
	Для каждого ЗаполняемаяСтрока Из ДЗПриемник Цикл
		Для каждого Колонка Из СписокКолонок Цикл
			Если ЗаполняемаяСтрока.Владелец.Колонки.Найти(Колонка.Значение) = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			ЗаполняемаяСтрока[Колонка.Значение] = Значение;
		КонецЦикла;
		Если ЗаполняемаяСтрока.Строки.Количество() > 0 Тогда
			ЗаполнитьКолонкиДЗ(ЗаполняемаяСтрока.Строки, ЗаполняемыеКолонки, ИсключаемыеКолонки, Значение);
		КонецЕсли;
	КонецЦикла;
	ВозВрат ДЗ;
КонецФункции // СкопироватьСтруктуруДЗвТЗ(ДЗ,ТЗ, СписокКолонок, СписокИсключаемыхКолонок)

// БоР : Выдает список колонок через запятую. В качестве входного значения может выступать СЗ,Структура,колонки ТЗ, КолонкиДЗ,список через запятую 16.06.2011 21:16:00
Функция СоздатьСтрокуКолонок(Знач Колонки) Экспорт
	
	СтрокаКолонок = "";
	Если ТипЗнч(Колонки) = Тип("Структура") Тогда
		СтрокаКолонок = "";
		Для каждого Элемент Из Колонки Цикл
			СтрокаКолонок = СтрокаКолонок + ?(СтрокаКолонок = "","",",") + СокрЛП(Элемент.Ключ);
		КонецЦикла;
	КонецЕсли;
	Если ТипЗнч(Колонки) = Тип("СписокЗначений") Тогда
		СтрокаКолонок = "";
		Для каждого Элемент Из Колонки Цикл
			СтрокаКолонок = СтрокаКолонок + ?(СтрокаКолонок = "","",",") + СокрЛП(Элемент.Значение);
		КонецЦикла;
	КонецЕсли;
	Если ТипЗнч(Колонки) = Тип("КоллекцияКолонокТаблицыЗначений") Тогда
		СтрокаКолонок = "";
		Для каждого Элемент Из Колонки Цикл
			СтрокаКолонок = СтрокаКолонок + ?(СтрокаКолонок = "","",",") + СокрЛП(Элемент.Имя);
		КонецЦикла;
	КонецЕсли;
	Если ТипЗнч(Колонки) = Тип("КоллекцияКолонокДереваЗначений") Тогда
		СтрокаКолонок = "";
		Для каждого Элемент Из Колонки Цикл
			СтрокаКолонок = СтрокаКолонок + ?(СтрокаКолонок = "","",",") + СокрЛП(Элемент.Имя);
		КонецЦикла;
	КонецЕсли;
	Если ТипЗнч(Колонки) = Тип("Массив") Тогда
		СтрокаКолонок = "";
		Для каждого Элемент Из Колонки Цикл
			СтрокаКолонок = СтрокаКолонок + ?(СтрокаКолонок = "","",",") + СокрЛП(Элемент);
		КонецЦикла;
	КонецЕсли;
	Если ТипЗнч(Колонки) = Тип("КолонкиСписка") Тогда
		СтрокаКолонок = "";
		Для каждого Элемент Из Колонки Цикл
			СтрокаКолонок = СтрокаКолонок + ?(СтрокаКолонок = "","",",") + СокрЛП(Элемент.Имя);
		КонецЦикла;
	КонецЕсли;
	Если ТипЗнч(Колонки) = Тип("КоллекцияКолонокРезультатаЗапроса") Тогда
		СтрокаКолонок = "";
		Для каждого Элемент Из Колонки Цикл
			СтрокаКолонок = СтрокаКолонок + ?(СтрокаКолонок = "","",",") + СокрЛП(Элемент.Имя);
		КонецЦикла;
	КонецЕсли;
	Если ТипЗнч(Колонки) = Тип("КоллекцияПолейXBase") Тогда
		СтрокаКолонок = "";
		Для каждого Элемент Из Колонки Цикл
			СтрокаКолонок = СтрокаКолонок + ?(СтрокаКолонок = "","",",") + СокрЛП(Элемент.Имя);
		КонецЦикла;
	КонецЕсли;
	
	ВозВрат СтрокаКолонок;
	// На будущее, если понадобится
	
	// СписокЗначений
	СписокКолонок = РазобратьСтрокуНаСлова(СтрокаКолонок, ",");
	ВозВрат СписокКолонок;
	
	// Структура, одинаковые колонки сворачиваются
	СтруктураКолонок = Новый Структура;
	Для каждого Элемент Из СписокКолонок Цикл
		СтруктураКолонок.Вставить(СокрЛП(Элемент.Значение));
	КонецЦикла;
	ВозВрат СтруктураКолонок;
	
	
КонецФункции

// БоР : Удаляет колонки (или просто подстроки), перечисленные через запятую в одном списке, из другого 16.06.2011 21:36:18
Функция ВычестьСписокКолонок(Знач СтрокаКолонок, СтрокаИсключаемыхКолонок) Экспорт
	
	Если СокрЛП(СтрокаКолонок) <> "" И СокрЛП(СтрокаИсключаемыхКолонок) <> "" Тогда
		СтрокаКолонок = "," + СокрЛП(СтрокаКолонок) + ",";
		СписокКолонок = РазобратьСтрокуНаСлова(СтрокаИсключаемыхКолонок, ",");
		Для каждого Колонка Из СписокКолонок Цикл
			СтрокаКолонок = СтрЗаменить(СтрокаКолонок, "," + Колонка.Значение + ",", "");
		КонецЦикла;
		СтрокаКолонок = Сред(СтрокаКолонок, 2, СтрДлина(СтрокаКолонок) - 2);
	КонецЕсли;
	
	ВозВрат СтрокаКолонок;
	
КонецФункции
#КонецОбласти
	
// БоР : Получает из запроса первую строку и возвращает в виде стпуктуры (при отсутствии - структура с пустыми значениями полей) 30.04.2017 17:00:20
Функция ПолучитьРезультатЗапросаКакСтруктуру(РезультатИлиВыборка) Экспорт
	// если выборка - считаем, что уже спозиционирована и проверена на успех позиционирования
	Если ТипЗнч(РезультатИлиВыборка) = Тип("ВыборкаИзРезультатаЗапроса") Тогда
		РезультатЗапроса = РезультатИлиВыборка.Владелец;
		Выборка = РезультатИлиВыборка;
		ВыборкаСпозиционирована = Истина;
	Иначе
		РезультатЗапроса = РезультатИлиВыборка;
		Выборка = РезультатЗапроса.Выбрать();
		ВыборкаСпозиционирована = Выборка.Следующий();
	КонецЕсли;
	СтруктураРезультат = Новый Структура;
	Для каждого Колонка Из РезультатЗапроса.Колонки Цикл
		СтруктураРезультат.Вставить(Колонка.Имя, БоР_ОбщийМодульКлиентСервер.ТипБезNULL(Колонка.ТипЗначения).ПривестиЗначение());
	КонецЦикла;
	
	Пока ВыборкаСпозиционирована Цикл
		ЗаполнитьЗначенияСвойств(СтруктураРезультат, Выборка);
		ВозВрат СтруктураРезультат;
	КонецЦикла;
	
	Возврат СтруктураРезультат;
КонецФункции

#КонецОбласти

#Область УправляемаяФорма
Процедура ОтобразитьДеревоНаФорме(Форма, ДЗ, ИмяРеквизитаФормы, ИмяЭлементаФормы, РодительЭлемента = Неопределено, ПередЭлементом = Неопределено, ПересоздаватьРеквизиты = Ложь, ПересоздаватьЭлементы = Ложь, ДобавлятьЭлементы = Ложь) Экспорт

	РеквизитДерева = Неопределено;
	
	#Область Изменение_Реквизитов_формы
	МассивУдаляемыхРеквизитов = Новый Массив;
	МассивРеквизитов = Форма.ПолучитьРеквизиты();
	Для каждого Реквизит Из МассивРеквизитов Цикл
		Если Реквизит.Имя = ИмяРеквизитаФормы Тогда
			Если ПересоздаватьРеквизиты Тогда
				МассивУдаляемыхРеквизитов.Добавить(Реквизит.Имя);
			Иначе
				РеквизитДерева = Реквизит;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Если МассивУдаляемыхРеквизитов.Количество() > 0 Тогда
		Форма.ИзменитьРеквизиты(, МассивУдаляемыхРеквизитов);
	КонецЕсли;
	
	МассивДобавляемыхРеквизитов = Новый Массив;
	Если РеквизитДерева = Неопределено Тогда
	    МассивДобавляемыхРеквизитов.Добавить(Новый РеквизитФормы(ИмяРеквизитаФормы, Новый ОписаниеТипов("ДеревоЗначений")));
	КонецЕсли;
	Если МассивДобавляемыхРеквизитов.Количество() > 0 Тогда
	    Форма.ИзменитьРеквизиты(МассивДобавляемыхРеквизитов);
	КонецЕсли;
	
	СуществующиеРеквизиты = Новый Соответствие;
	МассивРеквизитов = Форма.ПолучитьРеквизиты(ИмяРеквизитаФормы);
	Для каждого Реквизит Из МассивРеквизитов Цикл
		СуществующиеРеквизиты.Вставить(Реквизит.Имя, Реквизит);
	КонецЦикла;
	
	
	МассивУдаляемыхРеквизитов = Новый Массив;
	МассивДобавляемыхРеквизитов = Новый Массив;
	Для Каждого Колонка Из ДЗ.Колонки Цикл
		Если ПересоздаватьРеквизиты Тогда
			СуществующийРеквизит = СуществующиеРеквизиты[Колонка.Имя];
			Если СуществующийРеквизит <> Неопределено Тогда
				МассивУдаляемыхРеквизитов.Добавить(СуществующийРеквизит.Имя);
				СуществующиеРеквизиты.Удалить(Колонка.Имя);
			КонецЕсли;
	        МассивДобавляемыхРеквизитов.Добавить(Новый РеквизитФормы(Колонка.Имя, Колонка.ТипЗначения, ИмяРеквизитаФормы, Колонка.Заголовок));
		Иначе
			СуществующийРеквизит = СуществующиеРеквизиты[Колонка.Имя];
			Если СуществующийРеквизит = Неопределено Тогда
		        МассивДобавляемыхРеквизитов.Добавить(Новый РеквизитФормы(Колонка.Имя, Колонка.ТипЗначения, ИмяРеквизитаФормы, Колонка.Заголовок));
			//Иначе
			//	Если СуществующийРеквизит.ТипЗначения <> БоР_ОбщийМодульКлиентСервер.ТипБезNULL(Колонка.ТипЗначения) ИЛИ СуществующийРеквизит.Заголовок <> Колонка.Заголовок Тогда
			//		МассивУдаляемыхРеквизитов.Добавить(СуществующийРеквизит.Имя);
			//        МассивДобавляемыхРеквизитов.Добавить(Новый РеквизитФормы(Колонка.Имя, Колонка.ТипЗначения, ИмяРеквизитаФормы, Колонка.Заголовок));
			//	КонецЕсли;
			//	СуществующиеРеквизиты.Удалить(Колонка.Имя);
			КонецЕсли;
		КонецЕсли;
    КонецЦикла;
	//Для каждого СуществующийРеквизит Из СуществующиеРеквизиты Цикл
	//	МассивУдаляемыхРеквизитов.Добавить(СуществующийРеквизит.Ключ);
	//КонецЦикла;
    Форма.ИзменитьРеквизиты(МассивДобавляемыхРеквизитов, МассивУдаляемыхРеквизитов);
	#КонецОбласти

    Форма.ЗначениеВРеквизитФормы(ДЗ, ИмяРеквизитаФормы);

	Если ДобавлятьЭлементы Тогда
		#Область Изменение_Элементов_формы
		ЭлементДерева = Форма.Элементы.Найти(ИмяЭлементаФормы);
		Если ПересоздаватьЭлементы И ЭлементДерева <> Неопределено Тогда
			Форма.Элементы.Удалить(ЭлементДерева);
			ЭлементДерева = Неопределено;
		КонецЕсли;
		Если ЭлементДерева = Неопределено Тогда
			ЭлементДерева = Форма.Элементы.Добавить(ИмяЭлементаФормы, Тип("ТаблицаФормы"), РодительЭлемента, ПередЭлементом);
			ЭлементДерева.ПутьКДанным = ИмяРеквизитаФормы;
			ЭлементДерева.Отображение = ОтображениеТаблицы.Дерево;
		КонецЕсли;
		
		СуществующиеЭлементы = Новый Соответствие;
		ПодчиненныеЭлементы = ПолучитьВсеПодчиненныеЭлементыФормы(ЭлементДерева);
		Для каждого Элемент Из ПодчиненныеЭлементы Цикл
			Если ТипЗнч(Элемент) = Тип("ПолеФормы") Тогда
				СуществующиеЭлементы.Вставить(Элемент.ПутьКДанным, Элемент);
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого Колонка Из ДЗ.Колонки Цикл
			ПутьКДанным = ИмяРеквизитаФормы + "." + Колонка.Имя;
			СуществующийЭлемент = СуществующиеЭлементы[ПутьКДанным];
			Если СуществующийЭлемент = Неопределено Тогда
				ЭлементКолонки = Форма.Элементы.Добавить(Колонка.Имя, Тип("ПолеФормы"), ЭлементДерева);
				Если Колонка.ТипЗначения = Новый ОписаниеТипов("Булево") Тогда
					ЭлементКолонки.Вид = ВидПоляФормы.ПолеФлажка;
				Иначе
					ЭлементКолонки.Вид = ВидПоляФормы.ПолеВвода;
				КонецЕсли;
				ЭлементКолонки.ПутьКДанным = ПутьКДанным;
			Иначе
				СуществующиеЭлементы.Удалить(ПутьКДанным);
			КонецЕсли;
		КонецЦикла;
		Для каждого СуществующийЭлемент Из СуществующиеЭлементы Цикл
			Форма.Элементы.Удалить(СуществующийЭлемент.Значение);
		КонецЦикла;
		#КонецОбласти
	КонецЕсли;

КонецПроцедуры   

// БоР :  30.08.2017 0:23:42
Функция ПолучитьВсеПодчиненныеЭлементыФормы(ЭлементРодитель) Экспорт
	ПодчиненныеЭлементы = Новый Массив;
	Для каждого Элемент Из ЭлементРодитель.ПодчиненныеЭлементы Цикл
		Если ТипЗнч(Элемент) = Тип("ГруппаФормы") Тогда
			ПодчиненныеЭлементы.Добавить(Элемент);
			МассивПодчиненных = ПолучитьВсеПодчиненныеЭлементыФормы(Элемент);
			Для каждого ПодчиненныйЭлемент Из МассивПодчиненных Цикл
				ПодчиненныеЭлементы.Добавить(ПодчиненныйЭлемент);
			КонецЦикла;
		ИначеЕсли ТипЗнч(Элемент) = Тип("ТаблицаФормы") Тогда
			ПодчиненныеЭлементы.Добавить(Элемент);
			МассивПодчиненных = ПолучитьВсеПодчиненныеЭлементыФормы(Элемент);
			Для каждого ПодчиненныйЭлемент Из МассивПодчиненных Цикл
				ПодчиненныеЭлементы.Добавить(ПодчиненныйЭлемент);
			КонецЦикла;
		Иначе
			ПодчиненныеЭлементы.Добавить(Элемент);
		КонецЕсли;
	КонецЦикла;
	ВозВрат ПодчиненныеЭлементы;
КонецФункции


#КонецОбласти

#Область Процедуры_штрихкодирования_и_вспомогательные
////////////////////////////////////////////////////////////////////////////////////////
// БоР : Процедуры штрихкодирования и вспомогательные 04.08.2013 14:22:48

// БоР : 04.08.2013 13:36:51
Функция КонтрольныйСимволEAN(ШтрихКод, Тип) Экспорт

	Четн   = 0;
	Нечетн = 0;

	КоличествоИтераций = ?(Тип = 13, 6, 4);

	Для Индекс = 1 По КоличествоИтераций Цикл
		Если (Тип = 8) и (Индекс = КоличествоИтераций) Тогда
		Иначе
			Четн   = Четн   + Сред(ШтрихКод, 2 * Индекс, 1);
		КонецЕсли;
		Нечетн = Нечетн + Сред(ШтрихКод, 2 * Индекс - 1, 1);
	КонецЦикла;

	Если Тип = 13 Тогда
		Четн = Четн * 3;
	Иначе
		Нечетн = Нечетн * 3;
	КонецЕсли;

	КонтЦифра = 10 - (Четн + Нечетн) % 10;

	Возврат ?(КонтЦифра = 10, "0", Строка(КонтЦифра));

КонецФункции

// БоР : Генерация штрихкода для объекта 04.08.2013 14:13:41
Функция ПолучитьШтрихКодОбъекта(Объект, РеквизитКодаНомера) Экспорт
	
	КодНомер = Объект[РеквизитКодаНомера];
	Если Не ЗначениеЗаполнено(КодНомер) Тогда
		ВозВрат "";
	КонецЕсли;
	ПрефиксГода = "";
	
	МетаданныеОбъекта = Объект.Метаданные();
	Если Метаданные.Документы.Содержит(МетаданныеОбъекта) Тогда
		Если МетаданныеОбъекта.ПериодичностьНомера = Метаданные.СвойстваОбъектов.ПериодичностьНомераДокумента.Год Тогда
			ГодОбъектаОтРождестваДЛО = Год(Объект.Дата) - 2014;
			ПрефиксГода = Прав(Строка(ГодОбъектаОтРождестваДЛО), 1);
		КонецЕсли;
	КонецЕсли;
	
	ПрефиксВидаДокумента = ПолучитьПрефиксШтрихкодаВидаОбъекта(Объект) + ПрефиксГода;
	ДлинаНомераСНулями = 13 - 2 - СтрДлина(ПрефиксВидаДокумента);
	
	НомерСНулями = Формат(БоР_ОбщийМодуль.ВЧисло(КодНомер), "ЧЦ=" + ДлинаНомераСНулями + "; ЧН=; ЧВН=; ЧГ=");
	
	ШтрихКод = ПолучитьШтрихКодПоКоду(ПрефиксВидаДокумента + НомерСНулями);
	
	ВозВрат ШтрихКод;
КонецФункции

// БоР : Генерация штрихкода по произвольной строке (добавление специальных символов)
Функция ПолучитьШтрихКодПоКоду(КодНомер) Экспорт
	
	ШтрихКод = "2" + КодНомер;
	ШтрихКод = ШтрихКод + КонтрольныйСимволEAN(ШтрихКод, 13);
	
	ВозВрат ШтрихКод;
КонецФункции

// БоР : Выдает префикс документа в штрихкодах - две цифры. 04.08.2013 14:25:18
Функция ПолучитьПрефиксШтрихкодаВидаОбъекта(Объект) Экспорт
	
	Попытка
		ИмяВидаОбъекта = Объект.Метаданные().Имя;
	Исключение
		ВозВрат "00";
	КонецПопытки;
	
	Если 		ИмяВидаОбъекта = "Рецепт" Тогда  			// по мере необходимости - добавляем еще варианты. Тупо, но надежно.
		ВозВрат "01";
	ИначеЕсли 	ИмяВидаОбъекта = "БланкРецепта" Тогда  	// по мере необходимости - добавляем еще варианты. Тупо, но надежно.
		ВозВрат "02";
	ИначеЕсли 	ИмяВидаОбъекта = "СборочныйЛист" Тогда  	// по мере необходимости - добавляем еще варианты. Тупо, но надежно.
		ВозВрат "03";
	ИначеЕсли 	ИмяВидаОбъекта = "НакладнаяНаПеремещениеЛС" Тогда  	// по мере необходимости - добавляем еще варианты. Тупо, но надежно.
		ВозВрат "04";
	ИначеЕсли 	ИмяВидаОбъекта = "ИнвентаризацияТоваровПоСекторам" Тогда  	// по мере необходимости - добавляем еще варианты. Тупо, но надежно.
		ВозВрат "05";
	ИначеЕсли 	ИмяВидаОбъекта = "ПоступлениеЛСНаСклад" Тогда  	// по мере необходимости - добавляем еще варианты. Тупо, но надежно.
		ВозВрат "06";
	ИначеЕсли 	ИмяВидаОбъекта = "ПриемкаЛСНаСклад" Тогда  	// по мере необходимости - добавляем еще варианты. Тупо, но надежно.
		ВозВрат "07";
	ИначеЕсли 	ИмяВидаОбъекта = "ВозвратЛСНаСклад" Тогда  	// по мере необходимости - добавляем еще варианты. Тупо, но надежно.
		ВозВрат "08";	
	ИначеЕсли 	ИмяВидаОбъекта = "ВозвратЛССоСклада" Тогда  	// по мере необходимости - добавляем еще варианты. Тупо, но надежно.
		ВозВрат "11";	
	// Начало  ( Фурман , 30.01.2015 16.37
	// Документ.ЗаявкаПоставщику будет удален. Вероятно, после удаления префикс "09" можно будет задействовать
	//ИначеЕсли 	ИмяВидаОбъекта = "ЗаявкаПоставщику" Тогда //Кушков Павел, Задача № 14619, 24.11.2014 // по мере необходимости - добавляем еще варианты. Тупо, но надежно.
	//	ВозВрат "09";
	// Окончание) Фурман , 30.01.2015 16.37
	//ИначеЕсли 	ИмяВидаОбъекта = "ЗаявкаПоГосссссссКонтрактуууууу" Тогда //Фурман 2015-11-25-19-36 Подчистка от старых ГК
	//	ВозВрат "10"; 
	ИначеЕсли 	ИмяВидаОбъекта = "ВнутреннееПеремещениеЛС_НаСкладе" Тогда //Кушков Павел, Задача № 17837, 19.03.2015 // по мере необходимости - добавляем еще варианты. Тупо, но надежно.
		ВозВрат "12";
	ИначеЕсли 	ИмяВидаОбъекта = "ПоступлениеЛСНаСклад" Тогда //Кушков Павел, Задача № 17837, 19.03.2015 // по мере необходимости - добавляем еще варианты. Тупо, но надежно.
		ВозВрат "13";
	ИначеЕсли 	ИмяВидаОбъекта = "РецептМК" Тогда  	// по мере необходимости - добавляем еще варианты. Тупо, но надежно.
		ВозВрат "14";
	ИначеЕсли 	ИмяВидаОбъекта = "ПоступлениеЛСНаСкладМК" Тогда 
		ВозВрат "15";
	ИначеЕсли 	ИмяВидаОбъекта = "НакладнаяНаПеремещениеЛСМК" Тогда 
		ВозВрат "16";
	ИначеЕсли 	ИмяВидаОбъекта = "АктСписанияМК" Тогда 
		ВозВрат "17";
	ИначеЕсли 	ИмяВидаОбъекта = "СписаниеЛССоСкладаМК" Тогда 
		ВозВрат "18";
	ИначеЕсли 	ИмяВидаОбъекта = "ЗаданиеНаПроизводствоМК" Тогда 
		ВозВрат "19";
	
	ИначеЕсли 	ИмяВидаОбъекта = "ПартииНоменклатуры" Тогда  	// по мере необходимости - добавляем еще варианты. Тупо, но надежно.
		ВозВрат "98";
	ИначеЕсли 	ИмяВидаОбъекта = "Пользователи" Тогда  	// по мере необходимости - добавляем еще варианты. Тупо, но надежно.
		ВозВрат "99";
	Иначе
		ВозВрат "00";
	КонецЕсли;
	
КонецФункции

Функция ПолучитьКартинкуШтрихкода(ПараметрыШтрихкода, РазмерыВПикселях = Ложь) Экспорт
	
	ВнешняяКомпонента = Бор_ПовторноеИспользованиеСервер.ПодключитьВнешнююКомпонентуПечатиШтрихкода();
	
	Если ВнешняяКомпонента = Неопределено Тогда
		ЗаписьЖурналаРегистрации("Штрихкод", УровеньЖурналаРегистрации.Ошибка, , , "Не удалось подключить компоненту печати штрихкода");
		ВозВрат Неопределено; // сигнал об ошибке
	КонецЕсли;
	
	Если РазмерыВПикселях Тогда
		ШиринаШтрихкодаВПикселях = Окр(ПараметрыШтрихкода.Ширина);
		ВысотаШтрихкодаВПикселях = Окр(ПараметрыШтрихкода.Высота);
	Иначе
		Макет = ПолучитьОбщийМакет("ЭталонДлины");
		КоличествоМиллиметровВПикселе = Макет.Рисунки.Квадрат100Пикселей.Высота / 100;
		ШиринаШтрихкодаВПикселях = Окр(ПараметрыШтрихкода.Ширина / КоличествоМиллиметровВПикселе);
		ВысотаШтрихкодаВПикселях = Окр(ПараметрыШтрихкода.Высота / КоличествоМиллиметровВПикселе);
	КонецЕсли;
	
	////////////////////////////////////////////////////////////////////////////////////////
	// БоР : Ненужное закомментировать 09.03.2015 17:31:21
	Если ВнешняяКомпонента.Версия >= "8.2.1.5" Тогда
		//ШиринаШтрихкода = ПараметрыШтрихкода.Ширина;
		//ВысотаШтрихкода = ПараметрыШтрихкода.Высота;
		
		ШиринаШтрихкода = ШиринаШтрихкодаВПикселях;
		ВысотаШтрихкода = ВысотаШтрихкодаВПикселях;
	Иначе
		ШиринаШтрихкода = ПараметрыШтрихкода.Ширина;
		ВысотаШтрихкода = ПараметрыШтрихкода.Высота;
		
		//ШиринаШтрихкода = ШиринаШтрихкодаВПикселях;
		//ВысотаШтрихкода = ВысотаШтрихкодаВПикселях;
	КонецЕсли;
	// БоР : Ненужное закомментировать 09.03.2015 17:31:21
	////////////////////////////////////////////////////////////////////////////////////////
	
	//Коды типов штрихкода:
	//EAN8 - 0
	//EAN13 - 1
	//128 - 2
	//CODE39 - 3
	//CODE128 - 4
	//CODE16K - 5
	//PDF417 - 6
	//STANDARD2OF5- 7
	//INTERLEAVED2OF5 - 8
	//CODE39EXT - 9
	//CODE93 - 10

	//Режим выравнивания штрихкода:
	//AUTO - 0
	//LEFT - 1
	//CENTER - 2
	//RIGHT - 3

	//Режим выравнивания текста:
	//CENTER - 0
	//LEFT - 1
	//RIGHT - 2
	//FULL - 3
	//EAN1 - 4
	//EAN2 - 5
	//EAN3 - 6
	
	////////////////////////////////////////////////////////////////////////////////////////
	// БоР : Этот вариант - работает со старой компонентой. Совершенно непонятно, как 26.03.2015 23:03:44
	//ВнешняяКомпонента.Ширина			= Мин(ПараметрыШтрихкода.Ширина, ВнешняяКомпонента.МинимальнаяШиринаКода);
	//ВнешняяКомпонента.Высота			= ПараметрыШтрихкода.Высота;
	//ВнешняяКомпонента.АвтоТип			= Ложь;
	//ВнешняяКомпонента.ТипКода			= ПараметрыШтрихкода.ТипКода;
	//ВнешняяКомпонента.ОтображатьТекст	= ПараметрыШтрихкода.ОтображатьТекст;
	//ВнешняяКомпонента.РазмерШрифта		= ПараметрыШтрихкода.РазмерШрифта;
	//ВнешняяКомпонента.СодержитКС		= ПараметрыШтрихкода.ТипКода = 1; // EAN13 содержит контрольный символ, остальные пока не интересуют
	//ВнешняяКомпонента.ЗначениеКода		= ПараметрыШтрихкода.Штрихкод;
	
	// БоР : Могут появляться сообщения об ошибке компоненты - видимо, когда размер шрифта не соответствует размеру картинки. 09.03.2015 17:33:20
	// БоР : Как это соответсвие определяется - неясно 09.03.2015 17:33:20
	// БоР : Решается (пока) подбором  09.03.2015 17:33:20
	ВнешняяКомпонента.Ширина			= Макс(ШиринаШтрихкода, ВнешняяКомпонента.МинимальнаяШиринаКода);
	ВнешняяКомпонента.Высота			= Макс(ВысотаШтрихкода, ВнешняяКомпонента.МинимальнаяВысотаКода);
	ВнешняяКомпонента.РазмерШрифта		= ПараметрыШтрихкода.РазмерШрифта + 2;
	ВнешняяКомпонента.АвтоТип			= Ложь;
	ВнешняяКомпонента.ТипКода			= ПараметрыШтрихкода.ТипКода;
	ВнешняяКомпонента.ОтображатьТекст	= ПараметрыШтрихкода.ОтображатьТекст;
	Если ПараметрыШтрихкода.Свойство("УголПоворота") и ЗначениеЗаполнено(ПараметрыШтрихкода.УголПоворота) Тогда
		ВнешняяКомпонента.УголПоворота 	= ПараметрыШтрихкода.УголПоворота;
	Иначе 
		ВнешняяКомпонента.УголПоворота 	= 0;
	КонецЕсли;
	ВнешняяКомпонента.СодержитКС		= ПараметрыШтрихкода.ТипКода = 1; // EAN13 содержит контрольный символ, остальные пока не интересуют
	ВнешняяКомпонента.ЗначениеКода		= ПараметрыШтрихкода.Штрихкод;

	ДвоичныеДанныеКартинки = ВнешняяКомпонента.ПолучитьШтрихкод();
	Если ДвоичныеДанныеКартинки <> Неопределено Тогда
		Возврат Новый Картинка(ДвоичныеДанныеКартинки);
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// БоР : Создает штрихкод EAN13 и помещает в рисунок печатной формы 28.08.2013 1:36:08
Функция СоздатьШтрихкодEAN13(Рисунок, Штрихкод) Экспорт
	
	ПараметрыШтрихкода = Новый Структура;
	ПараметрыШтрихкода.Вставить("Ширина"			, Рисунок.Ширина);
	ПараметрыШтрихкода.Вставить("Высота"			, Рисунок.Высота);
	ПараметрыШтрихкода.Вставить("Штрихкод"			, СокрЛП(Штрихкод));
	ПараметрыШтрихкода.Вставить("ТипКода"			, 1);
	ПараметрыШтрихкода.Вставить("ОтображатьТекст"	, Истина);
	ПараметрыШтрихкода.Вставить("РазмерШрифта"		, 12);
	
	Картинка = БоР_ОбщийМодуль.ПолучитьКартинкуШтрихкода(ПараметрыШтрихкода);
	Рисунок.Картинка = Картинка;
КонецФункции

//
// Параметры:
//  QRСтрока         - Строка - данные, которые необходимо разместить в QR-коде.
//
//  УровеньКоррекции - Число - уровень погрешности изображения при котором данный QR-код все еще возможно 100%
//                             распознать.
//                     Параметр должен иметь тип целого и принимать одно из 4 допустимых значений:
//                     0(7% погрешности), 1(15% погрешности), 2(25% погрешности), 3(35% погрешности).
//
//  Размер           - Число - определяет длину стороны выходного изображения в пикселях.
//                     Если минимально возможный размер изображения больше этого параметра - код сформирован не будет.
//
//  ТекстОшибки      - Строка - в этот параметр помещается описание возникшей ошибки (если возникла).
//
// Возвращаемое значение:
//  ДвоичныеДанные  - буфер, содержащий байты PNG-изображения QR-кода.
// 
// Пример:
//  
//  // Выводим на печать QR-код, содержащий в себе информацию зашифрованную по УФЭБС.
//
//  QRСтрока = УправлениеПечатью.ФорматнаяСтрокаУФЭБС(РеквизитыПлатежа);
//  ТекстОшибки = "";
//  ДанныеQRКода = УправлениеПечатью.ДанныеQRКода(QRСтрока, 0, 190, ТекстОшибки);
//  Если Не ПустаяСтрока(ТекстОшибки)
//      ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки);
//  КонецЕсли;
//
//  КартинкаQRКода = Новый Картинка(ДанныеQRКода);
//  ОбластьМакета.Рисунки.QRКод.Картинка = КартинкаQRКода;
//
Функция ПолучитьКартинкуQRКода(ПараметрыQRКода, РазмерыВПикселях = Ложь) Экспорт
	
	Если РазмерыВПикселях Тогда
		РазмерQRКодаВПикселях = Окр(ПараметрыQRКода.Размер);
	Иначе
		Макет = ПолучитьОбщийМакет("ЭталонДлины");
		КоличествоМиллиметровВПикселе = Макет.Рисунки.Квадрат100Пикселей.Высота / 100;
		РазмерQRКодаВПикселях = Окр(ПараметрыQRКода.Размер / КоличествоМиллиметровВПикселе);
	КонецЕсли;
	УровеньКоррекции	= Окр(ПараметрыQRКода.УровеньКоррекции);
	ЗначениеКода		= ПараметрыQRКода.ЗначениеКода;
	
	ВнешняяКомпонента = Бор_ПовторноеИспользованиеСервер.ПодключитьВнешнююКомпонентуПечатиQRКода();
	
	Если ВнешняяКомпонента = Неопределено Тогда
		ЗаписьЖурналаРегистрации("QRКод", УровеньЖурналаРегистрации.Ошибка, , , "Не удалось подключить компоненту печати QRКода");
		ВозВрат Неопределено; // сигнал об ошибке
	КонецЕсли;
	
	ДвоичныеДанныеКартинки = ВнешняяКомпонента.GenerateQRCode(ЗначениеКода, УровеньКоррекции, РазмерQRКодаВПикселях);
	Если ДвоичныеДанныеКартинки <> Неопределено Тогда
		Возврат Новый Картинка(ДвоичныеДанныеКартинки);
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// БоР : Создает штрихкод EAN13 и помещает в рисунок печатной формы 28.08.2013 1:36:08
Функция СоздатьQRКод(Рисунок, ЗначениеКода) Экспорт
	
	ПараметрыШтрихкода = Новый Структура;
	ПараметрыШтрихкода.Вставить("Размер"			, Мин(Рисунок.Высота, Рисунок.Ширина));
	ПараметрыШтрихкода.Вставить("ЗначениеКода"		, СокрЛП(ЗначениеКода));
	ПараметрыШтрихкода.Вставить("УровеньКоррекции"	, 0);
	
	Картинка = БоР_ОбщийМодуль.ПолучитьКартинкуQRКода(ПараметрыШтрихкода);
	Рисунок.Картинка = Картинка;
	Рисунок.РазмерКартинки = РазмерКартинки.Пропорционально;
	
КонецФункции
// БоР : Процедуры штрихкодирования и вспомогательные 04.08.2013 14:22:48
////////////////////////////////////////////////////////////////////////////////////////
#КонецОбласти

#Область Метаданные

Функция ПолучитьИмяОбъектаПоСсылке(СсылкаНаОбъект) Экспорт
	ВозВрат СсылкаНаОбъект.Метаданные().Имя;
КонецФункции

#КонецОбласти
// БоР : Функция возвращает таблицу движений для промежточного заполнения, которую можно потом загрузить в набор 09.11.2016 16:59:19
Функция ПолучитьТаблицуДвижений(МенеджерРегистра) Экспорт
	ТаблицаДвижений = МенеджерРегистра.СоздатьНаборЗаписей().ВыгрузитьКолонки();
	Если ТаблицаДвижений.Колонки.Найти("Активность") <> Неопределено Тогда
		ТаблицаДвижений.Колонки.Удалить("Активность");
	КонецЕсли;
	ВозВрат ТаблицаДвижений;
КонецФункции

Функция ЭтоПлатформа83БезРежимаСовместимости() Экспорт
	
	ВозВрат Бор_ПовторноеИспользованиеСервер.ЭтоПлатформа83БезРежимаСовместимости();
	
КонецФункции

Функция ПоместитьТабличнуюЧастьВХранилище(Знач ТабличнаяЧасть, УникальныйИдентификатор) Экспорт
	ВозВрат ПоместитьВоВременноеХранилище(ТабличнаяЧасть.Выгрузить(), УникальныйИдентификатор);
КонецФункции

Функция ПоместитьТабличнуюЧастьОбъектаВХранилище(Объект, ИмяТабличнойЧасти, УникальныйИдентификатор) Экспорт
	ВозВрат ПоместитьВоВременноеХранилище(Объект[ИмяТабличнойЧасти].Выгрузить(), УникальныйИдентификатор);
КонецФункции

Функция ПосмотретьВТ(Менеджер, ИмяВТ) Экспорт
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = Менеджер;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ВТ.*
	|ИЗ
	|	" + ИмяВТ + " КАК ВТ";
	
	ВозВрат Запрос.Выполнить().Выгрузить();
	 
КонецФункции

#Область Работа_с_настройками_форм_через_хранилище_настроек_Может_использоваться_для_хранения_в_базе_настроек_обработок
// БоР : Заполнение настроек формы, взятых из хранилища 18.10.2013 0:34:55
Процедура ЗаполнитьНастройкиФормыИзСохраненныхНастроекФормы(Форма, СохраненныеНастройки) Экспорт
	Для каждого Настройка Из СохраненныеНастройки Цикл
		Попытка
			ЗначениеНастройки = Настройка.Значение;
			Выполнить("Форма." + Настройка.Ключ + " = ЗначениеНастройки");
		Исключение
			//значит, не пришлось
		КонецПопытки;
	КонецЦикла;
КонецПроцедуры

// БоР : Заполнение настроек формы, взятых из хранилища 18.10.2013 0:34:55
Процедура ЗаполнитьНастройкиОбъектаИзСохраненныхНастроекФормы(Объект, СохраненныеНастройки) Экспорт
	Для каждого Настройка Из СохраненныеНастройки Цикл
		Попытка
			ЗначениеНастройки = Настройка.Значение;
			Выполнить("Форма." + Настройка.Ключ + " = ЗначениеНастройки");
		Исключение
			//значит, не пришлось
		КонецПопытки;
	КонецЦикла;
КонецПроцедуры

Процедура ЗагрузитьНастройкиОбработкиВФорме(Форма, СсылкаНаХранилищеНастройки) Экспорт
	Если Не ЗначениеЗаполнено(СсылкаНаХранилищеНастройки) Тогда
		//Сообщение = Новый СообщениеПользователю;
		//Сообщение.Текст = "Не указан элемент - хранилище настройки";
		//Сообщение.Сообщить();
		ВозВрат;
	КонецЕсли;
	ОбработкаОбъект = Форма.РеквизитФормыВЗначение("Объект");
	Справочники.ХранилищеНастроекОбработок.ВосстановитьДанныеОбработки(ОбработкаОбъект, СсылкаНаХранилищеНастройки);
	Форма.ЗначениеВРеквизитФормы(ОбработкаОбъект, "Объект");
КонецПроцедуры

Функция ПолучитьАвтосохраненныеНастройкиОбработки(КлючОбъекта) Экспорт
	Если Не ЗначениеЗаполнено(КлючОбъекта) Тогда
		ВозВрат Неопределено;
	КонецЕсли;

	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ХранилищеНастроекОбработок.Ссылка
	|ИЗ
	|	Справочник.ХранилищеНастроекОбработок КАК ХранилищеНастроекОбработок
	|ГДЕ
	|	ХранилищеНастроекОбработок.Пользователь = &Пользователь
	|	И ХранилищеНастроекОбработок.КлючОбъекта = &КлючОбъекта
	|	И ХранилищеНастроекОбработок.Наименование = ""Автосейф""";
	
	Запрос.УстановитьПараметр("КлючОбъекта"		, КлючОбъекта);
	Запрос.УстановитьПараметр("Пользователь"	, Пользователи.ТекущийПользователь());
	
	РезультатЗапроса = Запрос.Выполнить();
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		ВозВрат ВыборкаДетальныеЗаписи.Ссылка;
	КонецЦикла;

	ВозВрат Неопределено;
КонецФункции

Процедура СохранитьНастройкиОбработкиВФорме(Форма, СсылкаНаХранилищеНастройки) Экспорт
	Если Не ЗначениеЗаполнено(СсылкаНаХранилищеНастройки) Тогда
		//Сообщение = Новый СообщениеПользователю;
		//Сообщение.Текст = "Не указан элемент - хранилище настройки";
		//Сообщение.Сообщить();
		ВозВрат;
	КонецЕсли;
	ОбработкаОбъект = Форма.РеквизитФормыВЗначение("Объект");
	Справочники.ХранилищеНастроекОбработок.СохранитьДанныеОбработки(ОбработкаОбъект, СсылкаНаХранилищеНастройки);
	Форма.ЗначениеВРеквизитФормы(ОбработкаОбъект, "Объект");
КонецПроцедуры
#КонецОбласти

#Область Полезное_для_прогресс_бара
// БоР : Оценка времени, оставшегося до окончания операции 06.10.2007 21:25:04
Функция ОценкаОставшегосяВремениРаботы(ПрошлоВремени, Сделано, ВсегоНадоСделать) Экспорт
	
	ВозВрат ПрошлоВремени / ?(Сделано = 0, 1, Сделано) * ?(ВсегоНадоСделать - Сделано < 0,0,ВсегоНадоСделать - Сделано);
	
КонецФункции // ОценкаВремениРаботы()

// БоР : Формирует сообщение о времени для длительной обработки 26.01.2015 23:07:11
Функция ПолучитьСведенияОбОстаткеВремени(ТекущееЗначение, МаксимальноеЗначение, НачалоРаботы, ТекущаяДата = Неопределено, ШаблонСообщения = Неопределено) Экспорт
	Если Не ЗначениеЗаполнено(ТекущаяДата) Тогда
		ТекущаяДата = ТекущаяДата();
	КонецЕсли;
	ПрошлоСекунд		= ТекущаяДата - НачалоРаботы;
	ПрошлоДней			= Цел(ПрошлоСекунд/86400);
	ОсталосьСекунд		= ОценкаОставшегосяВремениРаботы(ПрошлоСекунд, ТекущееЗначение, МаксимальноеЗначение);
	ОсталосьДней		= Цел(ОсталосьСекунд/86400);
	ПрошлоВремени		= ""+?(ПрошлоДней   = 0,"","" + ПрошлоДней   + " дн. ") + Формат('00010101'+ ПрошлоСекунд   , "ДЛФ=T");
	ОсталосьВремени		= ""+?(ОсталосьДней = 0,"","" + ОсталосьДней + " дн. ") + Формат('00010101'+ ОсталосьСекунд , "ДЛФ=T");
	ЗавершениеРаботы	= ТекущаяДата + ОсталосьСекунд;
	ЗначениеВПроцентах	=Формат(?(МаксимальноеЗначение=0, 0, ТекущееЗначение/МаксимальноеЗначение*100), "ЧЦ=10; ЧДЦ=4; ЧН=");
	
	
	Если Не ЗначениеЗаполнено(ШаблонСообщения) Тогда
		ШаблонСообщения = "Обработано &ЗначениеВПроцентах% (&ТекущееЗначение из &МаксимальноеЗначение)&ПСНачало: &НачалоРаботы&ПСПрошло: &ПрошлоВремени&ПСОсталось: &ОсталосьВремени&ПСЗавершение: &ЗавершениеРаботы";
	КонецЕсли;
	
	СтруктураПараметров = Новый Структура;
	СтруктураПараметров.Вставить("ТекущееЗначение"		, ТекущееЗначение);
	СтруктураПараметров.Вставить("МаксимальноеЗначение"	, МаксимальноеЗначение);
	СтруктураПараметров.Вставить("ЗначениеВПроцентах"	, ЗначениеВПроцентах);
	
	СтруктураПараметров.Вставить("НачалоРаботы"			, НачалоРаботы);
	СтруктураПараметров.Вставить("ТекущаяДата"			, ТекущаяДата);
	СтруктураПараметров.Вставить("ЗавершениеРаботы"		, ЗавершениеРаботы);
	
	СтруктураПараметров.Вставить("ПрошлоДней"			, ПрошлоДней);
	СтруктураПараметров.Вставить("ОсталосьДней"			, ОсталосьДней);
	
	СтруктураПараметров.Вставить("ПрошлоСекунд"			, ПрошлоСекунд);
	СтруктураПараметров.Вставить("ОсталосьСекунд"		, ОсталосьСекунд);
	
	СтруктураПараметров.Вставить("ПрошлоВремени"		, ПрошлоВремени);
	СтруктураПараметров.Вставить("ОсталосьВремени"		, ОсталосьВремени);
	
	ТекстСообщения = СформироватьТекстСообщения(ШаблонСообщения, СтруктураПараметров, Истина);
	СтруктураПараметров.Вставить("ТекстСообщения"		, ТекстСообщения);
	
	ВозВрат СтруктураПараметров;
КонецФункции // ОбновитьФормуИндикации()
#КонецОбласти

#Область Сериализация_XML
// БоР : Сериализует значение в строку XML 26.01.2009 18:05:39
Функция ЗначениеВXML(Значение) Экспорт
	
	ЗаписьЗначения = Новый ЗаписьXML;
	ЗаписьЗначения.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьЗначения, Значение, НазначениеТипаXML.Явное);
	//ЗаписатьXML(ЗаписьЗначения, Значение, НазначениеТипаXML.Явное); 
	ВозВрат ЗаписьЗначения.Закрыть();
	
КонецФункции

// БоР : Сериализует значение из строки XML 26.01.2009 18:05:39
Функция ЗначениеИзXML(ЗначениеXML, ТипЗначения = Неопределено) Экспорт
	Если ТипЗнч(ЗначениеXML) <> Тип("Строка") Тогда
		ВозВрат Неопределено;
	КонецЕсли;
	Если ПустаяСтрока(ЗначениеXML) Тогда
		ВозВрат Неопределено;
	КонецЕсли;
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(ЗначениеXML);
	ВозВрат СериализаторXDTO.ПрочитатьXML(ЧтениеXML, ТипЗначения);
	//ВозВрат ПрочитатьXML(ЧтениеXML);
	
КонецФункции

// БоР :  03.10.2013 5:04:41
Функция ПолучитьXDTOКакСтрокуXML(ЗначениеXDTO) Экспорт
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	ФабрикаXDTO.ЗаписатьXML(ЗаписьXML, ЗначениеXDTO);
	
	СтрокаXML = ЗаписьXML.Закрыть();
	ВозВрат СтрокаXML;
КонецФункции
#КонецОбласти

// БоР : Экспериментальная функция - создание копии объекта 19.04.2016 0:07:21
// БоР : Вариант достаточно сомнительный, но пока нет лучшего. Еще вариант через ЗначениеВСтрокуВнутр - не намного лучше 19.04.2016 0:07:21
Функция Скопировать(Знач Значение) Экспорт
	ВозВрат ЗначениеИзXML(ЗначениеВXML(Значение));
КонецФункции

#Область Права_Пользователи_Настройки
Функция ДоступныПолныеПрава() Экспорт
	Если РольДоступна(Метаданные.Роли.ПолныеПрава) Тогда
		ВозВрат Истина;
	Конецесли;
	ВозВрат Ложь;
КонецФункции

Функция ОпределитьДоступностьРоли(Роль) Экспорт
	ВозВрат РольДоступна(Роль);
КонецФункции

// БоР : Близнецы этих процедур есть в модуле ЗначенияНастроекПовтИсп, но там повторное использование 08.11.2013 1:46:27
Функция ПолучитьНастройкуПользователя(Пользователь, Настройка) Экспорт

	Если ТипЗнч(Настройка) = Тип("Строка") Тогда
		СсылкаНаНастройку = Бор_ПовторноеИспользованиеСервер.ПолучитьПредопределеннуюНастройкуПользователя(Настройка);
		Если Не ЗначениеЗаполнено(СсылкаНаНастройку) Тогда
			СсылкаНаНастройку = ПланыВидовХарактеристик.НастройкиПользователей.НайтиПоНаименованию(Настройка);
		КонецЕсли;
		Если Не ЗначениеЗаполнено(СсылкаНаНастройку) Тогда
			СсылкаНаНастройку = Неопределено;
		КонецЕсли;
	ИначеЕсли ТипЗнч(Настройка) = Тип("ПланВидовХарактеристикСсылка.НастройкиПользователей") Тогда
		СсылкаНаНастройку = Настройка;
	Иначе
		СсылкаНаНастройку = Неопределено;
	КонецЕсли;
	Если СсылкаНаНастройку = Неопределено Тогда
		ВозВрат Неопределено;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ГруппыПользователей.Ссылка
	|ПОМЕСТИТЬ ВТГруппыПользователя
	|ИЗ
	|	Справочник.ГруппыПользователей КАК ГруппыПользователей
	|ГДЕ
	|	ГруппыПользователей.Состав.Пользователь = &Пользователь
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	1 КАК Приоритет,
	|	НастройкиПользователей.Настройка,
	|	НастройкиПользователей.Значение
	|ПОМЕСТИТЬ ВТВсеНастройки
	|ИЗ
	|	РегистрСведений.НастройкиПользователей КАК НастройкиПользователей
	|ГДЕ
	|	НастройкиПользователей.Пользователь = &Пользователь
	|	И НастройкиПользователей.Настройка В(&МассивНастроек)
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	2,
	|	НастройкиПользователей.Настройка,
	|	МАКСИМУМ(НастройкиПользователей.Значение)
	|ИЗ
	|	ВТГруппыПользователя КАК ВТГруппыПользователя
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НастройкиПользователей КАК НастройкиПользователей
	|		ПО ВТГруппыПользователя.Ссылка = НастройкиПользователей.Пользователь
	|ГДЕ
	|	НастройкиПользователей.Настройка В(&МассивНастроек)
	|
	|СГРУППИРОВАТЬ ПО
	|	НастройкиПользователей.Настройка
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	3,
	|	НастройкиПользователей.Настройка,
	|	НастройкиПользователей.Значение
	|ИЗ
	|	РегистрСведений.НастройкиПользователей КАК НастройкиПользователей
	|ГДЕ
	|	НастройкиПользователей.Пользователь = ЗНАЧЕНИЕ(Справочник.ГруппыПользователей.ВсеПользователи)
	|	И НастройкиПользователей.Настройка В(&МассивНастроек)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	МИНИМУМ(ВТВсеНастройки.Приоритет) КАК Приоритет,
	|	ВТВсеНастройки.Настройка
	|ПОМЕСТИТЬ ВТМинимальныеПриоритеты
	|ИЗ
	|	ВТВсеНастройки КАК ВТВсеНастройки
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТВсеНастройки.Настройка
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТМинимальныеПриоритеты.Настройка,
	|	ВТВсеНастройки.Значение
	|ИЗ
	|	ВТМинимальныеПриоритеты КАК ВТМинимальныеПриоритеты
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТВсеНастройки КАК ВТВсеНастройки
	|		ПО ВТМинимальныеПриоритеты.Настройка = ВТВсеНастройки.Настройка
	|			И ВТМинимальныеПриоритеты.Приоритет = ВТВсеНастройки.Приоритет";

	Запрос.УстановитьПараметр("Пользователь"  , Пользователь);
	Запрос.УстановитьПараметр("МассивНастроек", СсылкаНаНастройку);
	Результат = Запрос.Выполнить();
	ВыборкаДетальныеЗаписи = Результат.Выбрать();
	Если ВыборкаДетальныеЗаписи.Следующий() Тогда
		ВозВрат ВыборкаДетальныеЗаписи.Значение;
	Иначе
		ВозВрат СсылкаНаНастройку.ТипЗначения.ПривестиЗначение(Неопределено);
	КонецЕсли;

КонецФункции

Функция ПолучитьНастройкиПользователя(Пользователь, СтруктураНастроек) Экспорт

	МассивНастроек = Новый Массив;
	Для каждого ЭлементНастройки Из СтруктураНастроек Цикл
		Попытка
			Настройка = ПланыВидовХарактеристик.НастройкиПользователей[ЭлементНастройки.Ключ];
			МассивНастроек.Добавить(Настройка);
		Исключение
		КонецПопытки;
	КонецЦикла; 
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ГруппыПользователей.Ссылка
	|ПОМЕСТИТЬ ВТГруппыПользователя
	|ИЗ
	|	Справочник.ГруппыПользователей КАК ГруппыПользователей
	|ГДЕ
	|	ГруппыПользователей.Состав.Пользователь = &Пользователь
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	1 КАК Приоритет,
	|	НастройкиПользователей.Настройка,
	|	НастройкиПользователей.Значение
	|ПОМЕСТИТЬ ВТВсеНастройки
	|ИЗ
	|	РегистрСведений.НастройкиПользователей КАК НастройкиПользователей
	|ГДЕ
	|	НастройкиПользователей.Пользователь = &Пользователь
	|	И НастройкиПользователей.Настройка В(&МассивНастроек)
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	2,
	|	НастройкиПользователей.Настройка,
	|	МАКСИМУМ(НастройкиПользователей.Значение)
	|ИЗ
	|	ВТГруппыПользователя КАК ВТГруппыПользователя
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НастройкиПользователей КАК НастройкиПользователей
	|		ПО ВТГруппыПользователя.Ссылка = НастройкиПользователей.Пользователь
	|ГДЕ
	|	НастройкиПользователей.Настройка В(&МассивНастроек)
	|
	|СГРУППИРОВАТЬ ПО
	|	НастройкиПользователей.Настройка
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	3,
	|	НастройкиПользователей.Настройка,
	|	НастройкиПользователей.Значение
	|ИЗ
	|	РегистрСведений.НастройкиПользователей КАК НастройкиПользователей
	|ГДЕ
	|	НастройкиПользователей.Пользователь = ЗНАЧЕНИЕ(Справочник.ГруппыПользователей.ВсеПользователи)
	|	И НастройкиПользователей.Настройка В(&МассивНастроек)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	МИНИМУМ(ВТВсеНастройки.Приоритет) КАК Приоритет,
	|	ВТВсеНастройки.Настройка
	|ПОМЕСТИТЬ ВТМинимальныеПриоритеты
	|ИЗ
	|	ВТВсеНастройки КАК ВТВсеНастройки
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТВсеНастройки.Настройка
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТМинимальныеПриоритеты.Настройка,
	|	ВТВсеНастройки.Значение
	|ИЗ
	|	ВТМинимальныеПриоритеты КАК ВТМинимальныеПриоритеты
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТВсеНастройки КАК ВТВсеНастройки
	|		ПО ВТМинимальныеПриоритеты.Настройка = ВТВсеНастройки.Настройка
	|			И ВТМинимальныеПриоритеты.Приоритет = ВТВсеНастройки.Приоритет";

	Запрос.УстановитьПараметр("Пользователь"  , Пользователь);
	Запрос.УстановитьПараметр("МассивНастроек", МассивНастроек);
	Результат = Запрос.Выполнить();
	ВыборкаДетальныеЗаписи = Результат.Выбрать();
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		ИмяПредопределенного = ПланыВидовХарактеристик.НастройкиПользователей.ПолучитьИмяПредопределенного(ВыборкаДетальныеЗаписи.Настройка);
		Если ЗначениеЗаполнено(ИмяПредопределенного) Тогда
			Если ВыборкаДетальныеЗаписи.Значение = NULL Тогда
				ВозВрат ВыборкаДетальныеЗаписи.Значение;
				СтруктураНастроек[ИмяПредопределенного] = ВыборкаДетальныеЗаписи.Настройка.ТипЗначения.ПривестиЗначение(Неопределено);
			Иначе
				СтруктураНастроек[ИмяПредопределенного] = ВыборкаДетальныеЗаписи.Значение;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	ВозВрат СтруктураНастроек;

КонецФункции

// БоР : Выдает список всех групп пользователя 06.09.2013 1:57:03
Функция ПолучитьВсеГруппыПользователя(Пользователь) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ГруппыПользователей.Ссылка
	|ИЗ
	|	Справочник.ГруппыПользователей КАК ГруппыПользователей
	|ГДЕ
	|	ГруппыПользователей.Состав.Пользователь = &Пользователь
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	ЗНАЧЕНИЕ(Справочник.ГруппыПользователей.ВсеПользователи)";
	
	Запрос.УстановитьПараметр("Пользователь"     , Пользователь);
	
	ВозВрат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	
КонецФункции
#КонецОбласти

// Формирует из исходной строки СтрокаПоиска строку для поиска данных в запросе
//
// Параметры:
//	СтрокаПоиска - Строка - исходная строка, содержащая запрещенные символы 	
//
// Возвращаемое значение:
//  Строка - строка подготовленная для поиска данных в запросе
//
Функция СформироватьСтрокуДляПоискаВЗапросе(Знач СтрокаПоиска) Экспорт
	
	ИтоговаяСтрокаДляПоиска = СтрокаПоиска;
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "~", "~~");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "%", "~%");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "_", "~_");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "[", "~[");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "]", "~]");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "^", "~^");
	
	Возврат ИтоговаяСтрокаДляПоиска;
	
КонецФункции

// Разбирает строку URI на составные части и возвращает в виде структуры.
// На основе RFC 3986.
//
// Параметры:
//  СтрокаURI - Строка - ссылка на ресурс в формате:
//    
//     <схема>://<логин>:<пароль>@<хост>:<порт>/<путь>?<параметры>#<якорь>
//               \______________/ \___________/
//                      |               |
//           	   авторизация     имя сервера
//               \____________________________/ \________________________/
//                              |                            |
//                       строка соединения            путь на сервере
//
// Возвращаемое значение:
//  Структура:
//             Схема         - Строка;
//             Логин         - Строка; 
//             Пароль        - Строка;
//             ИмяСервера    - Строка;
//             Хост          - Строка; 
//             Порт          - Строка; 
//             ПутьНаСервере - Строка;
//
Функция РазобратьURI(Знач СтрокаURI) Экспорт
    ////////////////////////////////////////////////////////////////////////////////////////
	// БоР : Взято из БСП и переделано 03.12.2013 20:59:56
	
	СтрокаURI = СокрЛП(СтрокаURI);
	СтрокаURI = СтрЗаменить(СтрокаURI, "\\", "//");
	
	// схема
	Схема = "";
	Позиция = Найти(СтрокаURI, "://");
	Если Позиция > 0 Тогда
		Схема = НРег(Лев(СтрокаURI, Позиция - 1));
		СтрокаURI = Сред(СтрокаURI, Позиция + 3);
	КонецЕсли;

	// строка соединения и путь на сервере
	СтрокаСоединения = СтрокаURI;
	ПутьНаСервере = "";
	Позиция = Найти(СтрокаСоединения, "/");
	Если Позиция > 0 Тогда
		ПутьНаСервере = Сред(СтрокаСоединения, Позиция + 1);
		СтрокаСоединения = Лев(СтрокаСоединения, Позиция - 1);
	КонецЕсли;
		
	// информация пользователя и имя сервера
	СтрокаАвторизации = "";
	ИмяСервера = СтрокаСоединения;
	Позиция = Найти(СтрокаСоединения, "@");
	Если Позиция > 0 Тогда
		СтрокаАвторизации = Лев(СтрокаСоединения, Позиция - 1);
		ИмяСервера = Сред(СтрокаСоединения, Позиция + 1);
	КонецЕсли;
	
	// логин и пароль
	Логин = СтрокаАвторизации;
	Пароль = "";
	Позиция = Найти(СтрокаАвторизации, ":");
	Если Позиция > 0 Тогда
		Логин = Лев(СтрокаАвторизации, Позиция - 1);
		Пароль = Сред(СтрокаАвторизации, Позиция + 1);
	КонецЕсли;
	
	// хост и порт
	Хост = ИмяСервера;
	Порт = "";
	Позиция = Найти(ИмяСервера, ":");
	Если Позиция > 0 Тогда
		Хост = Лев(ИмяСервера, Позиция - 1);
		Порт = Сред(ИмяСервера, Позиция + 1);
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("Схема", Схема);
	Результат.Вставить("Логин", Логин);
	Результат.Вставить("Пароль", Пароль);
	Результат.Вставить("ИмяСервера", ИмяСервера);
	Результат.Вставить("Хост", Хост);
	Результат.Вставить("Порт", Порт);
	Результат.Вставить("ПутьНаСервере", ПутьНаСервере);
	
	Возврат Результат;
	
КонецФункции

Функция НайтиПодчиненныйДокумент(ИмяЭтогоОбъекта, ДокументОснование, ИмяРеквизитаОснования = "ДокументОснование", НеучитываемаяСсылка = Неопределено, УчитыватьУдаленные = Ложь, УчитыватьНеПроведенные = Ложь) Экспорт

	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ОтгрузкаЛСИзПунктаОтпуска.Ссылка
	|ИЗ
	|	Документ.ОтгрузкаЛСИзПунктаОтпуска КАК ОтгрузкаЛСИзПунктаОтпуска
	|ГДЕ
	|	(Не ОтгрузкаЛСИзПунктаОтпуска.ПометкаУдаления
	|			ИЛИ &УчитыватьУдаленные)
	|	И (ОтгрузкаЛСИзПунктаОтпуска.Проведен
	|			ИЛИ &УчитыватьНеПроведенные)
	|	И ОтгрузкаЛСИзПунктаОтпуска.ДокументОснование = &ДокументОснование И &ДокументОснование <> Неопределено
	|	И (ОтгрузкаЛСИзПунктаОтпуска.Ссылка <> &НеучитываемаяСсылка)";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ОтгрузкаЛСИзПунктаОтпуска"	, ИмяЭтогоОбъекта);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, ".ДокументОснование ="			, "." + ИмяРеквизитаОснования + " =");

	Запрос.УстановитьПараметр("ДокументОснование"		, ?(ЗначениеЗаполнено(ДокументОснование), ДокументОснование, Неопределено));
	Запрос.УстановитьПараметр("НеучитываемаяСсылка"		, ?(ЗначениеЗаполнено(НеучитываемаяСсылка), НеучитываемаяСсылка, Неопределено));
	Запрос.УстановитьПараметр("УчитыватьНеПроведенные"	, УчитыватьНеПроведенные);
	Запрос.УстановитьПараметр("УчитыватьУдаленные"		, УчитыватьУдаленные);

	Результат = Запрос.Выполнить();

	ВыборкаДетальныеЗаписи = Результат.Выбрать();

	Если ВыборкаДетальныеЗаписи.Следующий() Тогда
		ВозВрат ВыборкаДетальныеЗаписи.Ссылка;
	КонецЕсли;
	ВозВрат Неопределено;
	
КонецФункции

// БоР : Универсальные и почти универсальные процедуры 25.06.2015 15:35:49
// БоР : Есть также блоки, требующие определенных метаданных, но достаточно общие для многих конфигураций  25.06.2015 15:35:49
////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////
// БоР : Процедуры, имеющие отношение к "универсальным" подсистемам и механизмам (типа БСП). Или очень часто встречающиеся 25.06.2015 15:40:28

// БоР :  18.01.2014 21:57:34
Функция ПроведениеБезПроверок(Знач СсылкаИлиОбъект, Знач ДополнительныеСвойства) Экспорт
	Если Не ЗначениеЗаполнено(ДополнительныеСвойства) Тогда
		ДополнительныеСвойства = СсылкаИлиОбъект.ДополнительныеСвойства;
	КонецЕсли;
	ДР = Бор_ПовторноеИспользованиеКлиентСервер.ПолучитьДоступностьРолей();
	Если Не ДР.ПолныеПрава Тогда
		ВозВрат Ложь;
	КонецЕсли;
	// БоР : Что-то здесь зачем-то исправил, а зачем, не помню. Исправлю назад 30.05.2014 3:05:42
	// БоР : Если не полные права - флажок не действует 30.05.2014 3:05:42
	//Если ДР.ПолныеПрава Тогда
	//	ВозВрат Истина;
	//КонецЕсли;
	МетаданныеОбъекта = СсылкаИлиОбъект.Метаданные();
	ПроведениеБезПроверок =
			БоР_ОбщийМодуль.ЕстьРеквизитОбъекта("ПроводитьБезПроверок", МетаданныеОбъекта) И СсылкаИлиОбъект.ПроводитьБезПроверок
			ИЛИ ДополнительныеСвойства.Свойство("ПроводитьБезПроверок") И ДополнительныеСвойства.ПроводитьБезПроверок
			ИЛИ БоР_ОбщийМодуль.ЕстьРеквизитОбъекта("ПровестиОдинРазБезПроверок", МетаданныеОбъекта) И СсылкаИлиОбъект.ПровестиОдинРазБезПроверок
			ИЛИ ДополнительныеСвойства.Свойство("ПровестиОдинРазБезПроверок") И ДополнительныеСвойства.ПровестиОдинРазБезПроверок;
	ВозВрат ПроведениеБезПроверок;
КонецФункции

// БоР :  18.01.2014 21:57:34
Функция УчестьПроведениеБезПроверок(Знач СсылкаИлиОбъект, Отказ, ДополнительныеСвойства = Неопределено) Экспорт
	БезусловноеПроведение = БоР_ОбщийМодуль.ПроведениеБезПроверок(СсылкаИлиОбъект, ДополнительныеСвойства);
	Отказ = Отказ И Не БезусловноеПроведение;
	Если ТипЗнч(ДополнительныеСвойства) = Тип("Структура") И ДополнительныеСвойства.Свойство("Отказ") Тогда
		ДополнительныеСвойства.Отказ = ДополнительныеСвойства.Отказ И Не БезусловноеПроведение;
	КонецЕсли;
КонецФункции

// БоР : Процедуры, имеющиеотношение к "универсальным" подсистемам и механизмам (типа БСП) 25.06.2015 15:40:28
////////////////////////////////////////////////////////////////////////////////////////


Функция ЗаполнитьТабличнуюЧастьИзПараметра(Форма, ИмяРеквизита, ИмяПараметра = Неопределено) Экспорт
	Если ИмяПараметра = Неопределено Тогда
		ИмяПараметра = ИмяРеквизита;
	КонецЕсли;
	РеквизитыФормы = Форма.ПолучитьРеквизиты();
	Для каждого РеквизитФормы Из РеквизитыФормы Цикл
		Если РеквизитФормы.Имя = ИмяРеквизита Тогда
			Если Форма.Параметры.Свойство(ИмяПараметра) И ЭтоАдресВременногоХранилища(Форма.Параметры[ИмяПараметра]) Тогда
				ТаблицаТЧ =ПолучитьИзВременногоХранилища(Форма.Параметры[ИмяПараметра]);
				Если ТипЗнч(ТаблицаТЧ) = Тип("ТаблицаЗначений")  Тогда
					Форма[ИмяРеквизита].Загрузить(ТаблицаТЧ);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
КонецФункции

Функция БорСтрРазделить(Строка, Разделитель, ВключатьПустые = Истина)  Экспорт
	Перем ИсходнаяСтрока;
	Перем КоличествоРазделителей;
	Перем Номер;
	Перем Символ;
	Перем МассивСтрок;
	Перем ОчереднаяСтрока;
	
	ИсходнаяСтрока = Строка;
	КоличествоРазделителей = СтрДлина(Разделитель);
	Для Номер = 1 По КоличествоРазделителей Цикл
		Символ = Сред(Разделитель, Номер, 1);
		ИсходнаяСтрока = СтрЗаменить(ИсходнаяСтрока, Разделитель, Символы.ПС);
	КонецЦикла;
	МассивСтрок = Новый Массив;
	Для Номер = 1 По СтрЧислоСтрок(ИсходнаяСтрока) Цикл
		ОчереднаяСтрока = СтрПолучитьСтроку(ИсходнаяСтрока, Номер);
		Если ЗначениеЗаполнено(ОчереднаяСтрока) ИЛИ ВключатьПустые Тогда
			МассивСтрок.Добавить(ОчереднаяСтрока);
		КонецЕсли;
	КонецЦикла;
	ВозВрат МассивСтрок;
КонецФункции

Функция ПолучитьНастройку(ИмяНастройки) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ИмяНастройки", ИмяНастройки);
	Запрос.Текст = "ВЫБРАТЬ
	               |	НастройкиСистемы.Значение КАК Значение
	               |ИЗ
	               |	РегистрСведений.НастройкиРасписанияЛК КАК НастройкиСистемы
	               |ГДЕ
	               |	НастройкиСистемы.ИмяНастройки = &ИмяНастройки";
	Результат = Запрос.Выполнить().Выгрузить();
	
	Если Результат.Количество() Тогда
		Возврат Результат[0].Значение;
	Иначе
		ЗаписьЖурналаРегистрации("Настройки РасписанияЛК", УровеньЖурналаРегистрации.Ошибка, , , "Не найдена настройка: """ + ИмяНастройки + """");
		//СоздатьНастройку(ИмяНастройки);
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции
Процедура УстановитьРежимПроведения(ДокументОбъект, РежимЗаписи, РежимПроведения) Экспорт

	Если ДокументОбъект.ДополнительныеСвойства.Свойство("РежимПроведенияДокумента") Тогда
		РежимПроведения = ДокументОбъект.ДополнительныеСвойства.РежимПроведенияДокумента;
	ИначеЕсли ДокументОбъект.Проведен И РежимЗаписи = РежимЗаписиДокумента.Проведение Тогда
		РежимПроведения = РежимПроведенияДокумента.Неоперативный;
	КонецЕсли;
	ДокументОбъект.ДополнительныеСвойства.Вставить("РежимПроведения", РежимПроведения);
	
КонецПроцедуры
