
// БоР : Открытие "модальной формы", с блокированием владельца - "этой" формы 23.09.2014 22:53:52
// БоР : Попытаемся сделать универсальную функцию для обычного и управляемого режима 03.02.2017 18:44:23
&НаКлиенте
Процедура ОткрытьБлокирующуюФорму(ВызывающаяФорма, ИмяФормы, ПараметрыФормы, Обработчик, ДополнительныеПараметры = Неопределено, РежимОткрытия = Неопределено) Экспорт
	Если РежимОткрытия = Неопределено Тогда
		РежимОткрытия = РежимОткрытияОкнаФормы.БлокироватьВесьИнтерфейс;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(Обработчик) Тогда
		ОписаниеОповещения = Неопределено;
	ИначеЕсли ТипЗнч(Обработчик) = Тип("ОписаниеОповещения") Тогда
		ОписаниеОповещения = Обработчик;
	Иначе
		ОписаниеОповещения = Новый ОписаниеОповещения(Обработчик, ВызывающаяФорма, ДополнительныеПараметры);
	КонецЕсли;
	
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		Если РежимОткрытия = РежимОткрытияОкнаФормы.БлокироватьВесьИнтерфейс ИЛИ РежимОткрытия = РежимОткрытияОкнаФормы.БлокироватьОкноВладельца Тогда
			РезультатОткрытия = ОткрытьФормуМодально(ИмяФормы, ПараметрыФормы, ВызывающаяФорма);
		Иначе
			РезультатОткрытия = ОткрытьФорму(ИмяФормы, ПараметрыФормы, ВызывающаяФорма);
		КонецЕсли;
		Если ТипЗнч(ОписаниеОповещения) = Тип("ОписаниеОповещения") Тогда
			ВыполнитьОбработкуОповещения(ОписаниеОповещения, РезультатОткрытия);
		КонецЕсли;
	#Иначе
		ОткрытьФорму(ИмяФормы, ПараметрыФормы, ВызывающаяФорма, , , , ОписаниеОповещения, РежимОткрытия);
	#КонецЕсли
	
КонецПроцедуры

#Область Старая_версия_ОткрытьБлокирующуюФорму
//Процедура ОткрытьБлокирующуюФорму(ВызывающаяФорма, ИмяФормы, ПараметрыФормы, Обработчик, ДополнительныеПараметры = Неопределено, РежимОткрытия = Неопределено) Экспорт
//	Если РежимОткрытия = Неопределено Тогда
//		РежимОткрытия = РежимОткрытияОкнаФормы.БлокироватьВесьИнтерфейс;
//	КонецЕсли;
//	Если Не ЗначениеЗаполнено(Обработчик) Тогда
//		ОписаниеОповещения = Неопределено;
//	Иначе
//		ОписаниеОповещения = Новый ОписаниеОповещения(Обработчик, ВызывающаяФорма, ДополнительныеПараметры);
//	КонецЕсли;
//	ОткрытьФорму(ИмяФормы, ПараметрыФормы, ВызывающаяФорма, , , , ОписаниеОповещения, РежимОткрытия);
//КонецПроцедуры
#КонецОбласти

// БоР : Сравнивает значения, в том числе и содержимое списков (без учета сортировки) 09.05.2012 15:10:38
Функция ЗначенияРавны(Значение1, Значение2) Экспорт
	
	Если ТипЗнч(Значение1) <> ТипЗнч(Значение2) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипЗнч(Значение1) = Тип("СписокЗначений") Тогда
		Если Значение1.Количество() <> Значение2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого Элемент1 Из Значение1 Цикл
			Для каждого Элемент2 Из Значение2 Цикл
				Если ЗначенияРавны(Элемент1.Значение, Элемент2.Значение) Тогда
					Найден = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Не Найден Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Для каждого Элемент2 Из Значение2 Цикл
			Для каждого Элемент1 Из Значение1 Цикл
				Если ЗначенияРавны(Элемент2.Значение, Элемент1.Значение) Тогда
					Найден = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Не Найден Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
	ИначеЕсли ТипЗнч(Значение1) = Тип("Массив") Тогда
		Если Значение1.Количество() <> Значение2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого Элемент1 Из Значение1 Цикл
			Для каждого Элемент2 Из Значение2 Цикл
				Если ЗначенияРавны(Элемент1, Элемент2) Тогда
					Найден = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Не Найден Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Для каждого Элемент2 Из Значение2 Цикл
			Для каждого Элемент1 Из Значение1 Цикл
				Если ЗначенияРавны(Элемент2, Элемент1) Тогда
					Найден = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Не Найден Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
	ИначеЕсли ТипЗнч(Значение1) = Тип("Структура") Тогда
		Если Значение1.Количество() <> Значение2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		Для каждого Элемент1 Из Значение1 Цикл
			ТекущееЗначение = Неопределено;
			Если НЕ Значение2.Свойство(Элемент1.Ключ, ТекущееЗначение) Тогда
				Возврат Ложь;
			КонецЕсли;
			Если Не ЗначенияРавны(Значение1.Значение, ТекущееЗначение) Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		Возврат Истина;
	Иначе
		Возврат Значение1 = Значение2;
	КонецЕсли;
	Возврат Ложь;
	
КонецФункции

#Область Перенесено_в_БоР_ОбщийМодульКлиентСервер
//// БоР : Находит и возвращает все элементы отбора (только в линейной структуре, не учитывая содержимое групп) 09.05.2012 15:06:48
//Функция НайтиЭлементыОтбора(ЭлементСтруктуры, ПолеОтбора, ВидСравнения = Неопределено, ЗначениеОтбора = Неопределено, Использование = Неопределено, Представление = Неопределено) Экспорт
//	
//	Если ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппировкаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ТаблицаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ДиаграммаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Настройки.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Настройки.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ОтборКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	Иначе// предполагаем, что это что-то, у чего есть поле "Отбор"
//		Отбор = ЭлементСтруктуры.Отбор;
//	КонецЕсли;
//	
//	Если ТипЗнч(ПолеОтбора) = Тип("Строка") Тогда
//		ПолеОтбора = Новый ПолеКомпоновкиДанных(ПолеОтбора);
//	КонецЕсли;
//	
//	МассивЭлементовОтбора = Новый Массив;
//	Для каждого ЭлементОтбора Из Отбор.Элементы Цикл
//		Если ТипЗнч(ЭлементОтбора) <> Тип("ЭлементОтбораКомпоновкиДанных") Тогда
//			// группы элементов ищем только по представлению
//			Если Представление <> Неопределено И ЭлементОтбора.Представление = Представление Тогда
//				МассивЭлементовОтбора.Добавить(ЭлементОтбора);
//				Продолжить;
//			КонецЕсли;
//			Продолжить;
//		КонецЕсли;
//		Если ВидСравнения <> Неопределено И ЭлементОтбора.ВидСравнения <> ВидСравнения Тогда
//			Продолжить;
//		КонецЕсли;
//		Если Представление <> Неопределено И ЭлементОтбора.Представление <> Представление Тогда
//			Продолжить;
//		КонецЕсли;
//		Если Использование <> Неопределено И ЭлементОтбора.Использование <> Использование Тогда
//			Продолжить;
//		КонецЕсли;
//		Если ЗначенияРавны(ЭлементОтбора.ЛевоеЗначение, ПолеОтбора) И (ЗначениеОтбора = Неопределено ИЛИ ЗначенияРавны(ЭлементОтбора.ПравоеЗначение, ЗначениеОтбора)) Тогда
//			МассивЭлементовОтбора.Добавить(ЭлементОтбора);
//			Продолжить;
//		КонецЕсли;
//		Если (ЗначениеОтбора = Неопределено ИЛИ ЗначенияРавны(ЭлементОтбора.ЛевоеЗначение, ЗначениеОтбора)) И ЗначенияРавны(ЭлементОтбора.ПравоеЗначение, ПолеОтбора) Тогда
//			МассивЭлементовОтбора.Добавить(ЭлементОтбора);
//			Продолжить;
//		КонецЕсли;
//	КонецЦикла;
//	ВозВрат МассивЭлементовОтбора;
//	
//КонецФункции // ПолучитьЭлементОтбора()

//// БоР : Добавляет в отбор элемент отбора по определенному полю 09.07.2009 14:01:22
//Функция ДобавитьЭлементОтбора(ЭлементСтруктуры, ПолеОтбора, ВидСравнения = Неопределено, ЗначениеОтбора = Неопределено, УдалятьСуществующие = Истина, Использование = Истина, Представление = Неопределено) Экспорт
//	
//	Если ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппировкаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ТаблицаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ДиаграммаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Настройки.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Настройки.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ОтборКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	Иначе// предполагаем, что это что-то, у чего есть поле "Отбор"
//		Отбор = ЭлементСтруктуры.Отбор;
//	КонецЕсли;
//	
//	Если ТипЗнч(ПолеОтбора) = Тип("Строка") Тогда
//		ПолеОтбора = Новый ПолеКомпоновкиДанных(ПолеОтбора);
//	КонецЕсли;
//	
//	Если ВидСравнения = Неопределено Тогда
//		ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
//	КонецЕсли;
//	
//	Если УдалятьСуществующие Тогда
//		МассивЭлементовОтбора = НайтиЭлементыОтбора(Отбор, ПолеОтбора, , , , Представление);
//		Для каждого ЭлементОтбора Из МассивЭлементовОтбора Цикл
//			Отбор.Элементы.Удалить(ЭлементОтбора);
//		КонецЦикла;
//	КонецЕсли;
//	
//	НовыйЭлементОтбора = Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
//	НовыйЭлементОтбора.Использование  = Использование;
//	НовыйЭлементОтбора.ВидСравнения   = ВидСравнения;
//	НовыйЭлементОтбора.ЛевоеЗначение  = ПолеОтбора;
//	НовыйЭлементОтбора.ПравоеЗначение = ЗначениеОтбора;
//	НовыйЭлементОтбора.Представление  = Представление;
//	НовыйЭлементОтбора.ИдентификаторПользовательскойНастройки = Строка(Новый УникальныйИдентификатор);
//	ВозВрат НовыйЭлементОтбора;
//КонецФункции // ДобавитьЭлементОтбора()

//// БоР :  21.07.2017 14:02:58
//Функция УдалитьЭлементОтбора(ЭлементСтруктуры, ПолеОтбора, Представление = Неопределено) Экспорт
//	
//	Если ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппировкаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ТаблицаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ДиаграммаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Настройки.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Настройки.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ОтборКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	Иначе// предполагаем, что это что-то, у чего есть поле "Отбор"
//		Отбор = ЭлементСтруктуры.Отбор;
//	КонецЕсли;
//	
//	Если ТипЗнч(ПолеОтбора) = Тип("Строка") Тогда
//		ПолеОтбора = Новый ПолеКомпоновкиДанных(ПолеОтбора);
//	КонецЕсли;
//	
//	МассивЭлементовОтбора = НайтиЭлементыОтбора(Отбор, ПолеОтбора, , , , Представление);
//	Для каждого ЭлементОтбора Из МассивЭлементовОтбора Цикл
//		Отбор.Элементы.Удалить(ЭлементОтбора);
//	КонецЦикла;
//	
//	ВозВрат Неопределено;
//	
//КонецФункции

//// БоР :  21.07.2017 14:02:58
//Функция УстановитьОтборПоПолю(ЭлементСтруктуры, Поле, Значение, Представление = "", ВидСравнения = Неопределено, УстанавливатьОтбор = Истина) Экспорт
//	Если ЗначениеЗаполнено(Значение) Тогда
//		ЭлементОтбора = БоР_ОбщийМодульКлиент.УдалитьЭлементОтбора(ЭлементСтруктуры, Поле, ?(Представление = "", "Отбор по полю " + Поле, Представление));
//	Иначе
//		ЭлементОтбора = БоР_ОбщийМодульКлиент.ДобавитьЭлементОтбора(ЭлементСтруктуры, Поле, ?(ВидСравнения = Неопределено, ВидСравненияКомпоновкиДанных.Равно, ВидСравнения), Значение, Истина, УстанавливатьОтбор, ?(Представление = "", "Отбор по полю " + Поле, Представление));
//	КонецЕсли;
//	ВозВрат ЭлементОтбора;
//КонецФункции

//// БоР : Добавляет в отбор элемент отбора по определенному полю 09.07.2009 14:01:22
//Функция ДобавитьГруппуОтбора(ЭлементСтруктуры, ТипГруппы, УдалятьСуществующие = Истина, Использование = Истина, Представление = Неопределено) Экспорт
//	
//	Если ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппировкаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ТаблицаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ДиаграммаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Настройки.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры.Настройки.Отбор;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ОтборКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
//		Отбор = ЭлементСтруктуры;
//	Иначе// предполагаем, что это что-то, у чего есть поле "Отбор"
//		Отбор = ЭлементСтруктуры.Отбор;
//	КонецЕсли;
//	
//	Если УдалятьСуществующие Тогда
//		МассивЭлементовОтбора = НайтиЭлементыОтбора(Отбор, , , , , Представление);
//		Для каждого ЭлементОтбора Из МассивЭлементовОтбора Цикл
//			Отбор.Элементы.Удалить(ЭлементОтбора);
//		КонецЦикла;
//	КонецЕсли;
//	
//	НовыйЭлементОтбора = Отбор.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
//	НовыйЭлементОтбора.Использование	= Использование;
//	НовыйЭлементОтбора.ТипГруппы		= ТипГруппы;
//	НовыйЭлементОтбора.Представление	= Представление;
//	НовыйЭлементОтбора.ИдентификаторПользовательскойНастройки = Строка(Новый УникальныйИдентификатор);
//	ВозВрат НовыйЭлементОтбора;
//КонецФункции // ДобавитьЭлементОтбора()
#КонецОбласти

// БоР : Разбирает одну строку на отдельныен слова в соответствии со списком разделителей  07.01.2007 1:20:05
Функция РазобратьСтрокуНаСлова(Знач СтрокаТекста, СписокРазделителей, ОставлятьПустыеСтроки = Ложь) Экспорт
	Для каждого Разделитель Из СписокРазделителей Цикл
		СтрокаТекста=СтрЗаменить(СтрокаТекста,Разделитель.Значение,Символы.ПС);
	КонецЦикла; 
	СЗ=Новый СписокЗначений();
	Для Н=1 По СтрЧислоСтрок(СтрокаТекста) Цикл
		ОчереднаяСтрока=СтрПолучитьСтроку(СтрокаТекста,Н);
		Если СокрЛП(ОчереднаяСтрока)<>"" ИЛИ ОставлятьПустыеСтроки Тогда
			СЗ.Добавить(СокрЛП(ОчереднаяСтрока));
		КонецЕсли;
	КонецЦикла;
	ВозВрат СЗ;
КонецФункции

// БоР : Преобразовывает значение в булево 06.04.2011 3:22:23
Функция ВБулево(ПочтиБулево) Экспорт
	ТипБулево = Новый ОписаниеТипов("Булево");
	Если ТипЗнч(ПочтиБулево) = Тип("Строка") И Не ЕстьНеЦифры(ПочтиБулево) Тогда
		ВозВрат ТипБулево.ПривестиЗначение(ВЧисло(ПочтиБулево));
	Иначе
		ВозВрат ТипБулево.ПривестиЗначение(ПочтиБулево);
	КонецЕсли;
КонецФункции // ВЧисло()

// БоР : Преобразовывает значение в число 11.01.2010 0:19:23
Функция ВЧисло(ПочтиЧисло) Экспорт
	ТипЧисло = Новый ОписаниеТипов("Число",Новый КвалификаторыЧисла(0, 0, ДопустимыйЗнак.Любой));
	ВозВрат ТипЧисло.ПривестиЗначение(ПочтиЧисло);
КонецФункции // ВЧисло()

// БоР : Преобразовывает значение в дату 11.01.2010 0:19:23
Функция ВДату(Знач ПочтиДата) Экспорт
	Если ТипЗнч(ПочтиДата) = Тип("СтандартнаяДатаНачала") Тогда
		ПочтиДата = ПочтиДата.Дата;
	КонецЕсли;
	ТипДата = Новый ОписаниеТипов("Дата", , ,Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя));
	ВозВрат ТипДата.ПривестиЗначение(ПочтиДата);
КонецФункции // ВДату()

// БоР : Функция проверяет наличие в строке только цифр 28.09.2008 18:16:27
Функция ЕстьНеЦифры(Знач СтрокаПроверки) Экспорт

	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Истина;
	КонецЕсли;
	
	СтрокаПроверки = СокрЛП(СтрокаПроверки);
	Длина = СтрДлина(СтрокаПроверки);
	
	Для а = 1 По Длина Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если (КодСимвола < 48) ИЛИ (КодСимвола > 57) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
	
КонецФункции

// БоР : Преобразует дату из дд.мм.гггг в дату 1С 07.01.2007 21:04:47
Функция ДатаИзСтроки(Знач ДатаСтрокой, Разделители = ".", Знач ПорядокСоставляющих = "ДМГчмс", ГодНачалаСтолетия = "30") Экспорт
	ПорядокСоставляющих = СокрЛП(ПорядокСоставляющих);
	ДатаСтрокойБыла = ДатаСтрокой;
	Если ПустаяСтрока(ДатаСтрокой) Тогда
		ВозВрат '0001-01-01';
	КонецЕсли;
	Если ТипЗнч(Разделители) = Тип("Строка") Тогда
		ДатаСтрокой = СтрЗаменить(ДатаСтрокой,Разделители,Символы.ПС);
	ИначеЕсли ТипЗнч(Разделители) = Тип("СписокЗначений") Тогда
		Для каждого Разделитель Из Разделители Цикл
			ДатаСтрокой = СтрЗаменить(ДатаСтрокой,Разделитель.Значение,Символы.ПС);
		КонецЦикла;
	ИначеЕсли ТипЗнч(Разделители) = Тип("Структура") Тогда
		Для каждого Разделитель Из Разделители Цикл
			ДатаСтрокой = СтрЗаменить(ДатаСтрокой,Разделитель.Значение,Символы.ПС);
		КонецЦикла;
	ИначеЕсли ТипЗнч(Разделители) = Тип("Соответствие") Тогда
		Для каждого Разделитель Из Разделители Цикл
			ДатаСтрокой = СтрЗаменить(ДатаСтрокой,Разделитель.Значение,Символы.ПС);
		КонецЦикла;
	Иначе
		ВозВрат '0001-01-01';
	КонецЕсли;
	Если СтрЧислоСтрок(ДатаСтрокой)<3 Тогда
		ВозВрат '0001-01-01';
	КонецЕсли; 
	ПозицияД = Найти(ПорядокСоставляющих,"Д");
	ПозицияМ = Найти(ПорядокСоставляющих,"М");
	ПозицияГ = Найти(ПорядокСоставляющих,"Г");
	Позиция_ч = Найти(ПорядокСоставляющих,"ч");
	Позиция_м = Найти(ПорядокСоставляющих,"м");
	Позиция_с = Найти(ПорядокСоставляющих,"с");
	
	ПозицияД = ?(ПозицияД = 0,1,ПозицияД);
	ПозицияМ = ?(ПозицияМ = 0,2,ПозицияМ);
	ПозицияГ = ?(ПозицияГ = 0,3,ПозицияГ);
	
	День  = СтрПолучитьСтроку(ДатаСтрокой,ПозицияД);
	Месяц = СтрПолучитьСтроку(ДатаСтрокой,ПозицияМ);
	Год   = СтрПолучитьСтроку(ДатаСтрокой,ПозицияГ);
	
	Если СтрДлина(Год) = 2 Тогда
		Если Год < ГодНачалаСтолетия Тогда
			Год = "20" + Год;
		Иначе
			Год = "19" + Год;
		КонецЕсли;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Позиция_ч) Тогда
		Часов = СтрПолучитьСтроку(ДатаСтрокой,Позиция_ч);
	Иначе
		Часов = "0";
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Позиция_м) Тогда
		Минут = СтрПолучитьСтроку(ДатаСтрокой,Позиция_м);
	Иначе
		Минут = "0";
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Позиция_с) Тогда
		Секунд = СтрПолучитьСтроку(ДатаСтрокой,Позиция_с);
	Иначе
		Секунд = "0";
	КонецЕсли;
	
	Попытка
		ВозВрат Дата(Год, Месяц, День, Часов, Минут, Секунд);
	Исключение
		//СообщитьИЗаписатьВЛог("Ошибка при преобразовании значения в дату : """+ДатаСтрокойБыла+"""!");
	КонецПопытки;
	
КонецФункции // ДатаИзСтроки(ДатаСой)

// БоР : Присваивает из одной переменной в другую 25.05.2009 5:31:38
Функция Присвоить(Куда, Что) Экспорт
	Куда = Что;
	ВозВрат Куда;
КонецФункции // Присвоить(Куда, Что)

// БоР : Выполняет кусок кода 25.05.2009 5:31:38
Функция ВыполнитьКод(Что) Экспорт
	Выполнить(Что);
	ВозВрат Истина;
КонецФункции

// БоР : Вычисляет выражение. Можно использовать например при COM-соединении 25.05.2009 5:31:38
Функция ВычислитьВыражение(Что) Экспорт
	ВозВрат Вычислить(Что);
КонецФункции

// БоР : Проверяет заполнение реквизита ТЧ на форме, так же, как при установке "выдавать ошибку" 06.10.2012 20:09:10
Процедура ПроверитьЗаполнениеРеквизитаТЧФормы(ИмяТЧ, ИмяПоля, Форма, Отказ, УсловиеПроверки = "Не ЗначениеЗаполнено(СтрокаТЧ[ИмяПоля])") Экспорт
	
	РеквизитыФормы = Форма.ПолучитьРеквизиты();
	Для каждого РеквизитФормы Из РеквизитыФормы Цикл
		Если РеквизитФормы.Имя = ИмяТЧ Тогда
			РеквизитТЧ = РеквизитФормы;
			НаименованиеТЧ = РеквизитТЧ.Заголовок;
		КонецЕсли;
	КонецЦикла;
	Если РеквизитТЧ <> Неопределено Тогда
		РеквизитыФормы = Форма.ПолучитьРеквизиты(РеквизитТЧ.Имя);
		Для каждого РеквизитФормы Из РеквизитыФормы Цикл
			Если РеквизитФормы.Имя = ИмяПоля Тогда
				РеквизитПоля = РеквизитФормы;
				НаименованиеПоля = РеквизитПоля.Заголовок;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Для каждого СтрокаТЧ Из Форма[ИмяТЧ] Цикл
		Если Вычислить(УсловиеПроверки) Тогда
			Отказ = Истина;
			Сообщение = Новый СообщениеПользователю;
			Сообщение.Текст = "Не заполнено поле """ + НаименованиеПоля + """ в строке " + (Форма[ИмяТЧ].Индекс(СтрокаТЧ) + 1) + " табличной части """ + НаименованиеТЧ + """.";
			Сообщение.Поле = ИмяТЧ + "[" + Форма[ИмяТЧ].Индекс(СтрокаТЧ) + "]." + ИмяПоля;
			Сообщение.Сообщить();
		КонецЕсли;
	КонецЦикла;
	
	
КонецПроцедуры

// БоР : Просматривает варианты компоновки и выдает по имени или первый, если по имени не найден 14.06.2011 18:05:45
Функция ПолучитьВариантКомпоновки(СхемаКомпоновки, ИмяВариантаНастройки = Неопределено) Экспорт
	Если ИмяВариантаНастройки <> Неопределено Тогда
		Для каждого Вариант Из СхемаКомпоновки.ВариантыНастроек Цикл
			Если Вариант.Имя = ИмяВариантаНастройки Тогда
				ВозВрат Вариант;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	ВозВрат СхемаКомпоновки.ВариантыНастроек[0];
КонецФункции //ПолучитьОбработчик()

// БоР : Проверяет ключ запуска, и, если это навигационная ссылка, переходит по ней 21.11.2012 20:04:49
Функция ПолучитьСсылкуИзПараметраЗапуска() Экспорт
	МаркерСсылки = "e1cib/";
	МаркерВнешнейСсылки = "#e1cib/";
	Если ЗначениеЗаполнено(ПараметрЗапуска) Тогда
		Если Лев(ПараметрЗапуска, СтрДлина(МаркерСсылки)) = МаркерСсылки Тогда
			СсылкаДляПерехода = ПараметрЗапуска;
		ИначеЕсли Найти(ПараметрЗапуска, МаркерВнешнейСсылки) > 0 Тогда
			СсылкаДляПерехода = ПараметрЗапуска;
		Иначе
			СсылкаДляПерехода = Неопределено;
		КонецЕсли;
	КонецЕсли;
	ВозВрат СсылкаДляПерехода;
КонецФункции

// БоР : Проверяет ключ запуска, и, если это навигационная ссылка, переходит по ней 21.11.2012 20:04:49
Процедура ОбработатьПараметрЗапуска() Экспорт
	СсылкаДляПерехода = ПолучитьСсылкуИзПараметраЗапуска();
	Если ЗначениеЗаполнено(СсылкаДляПерехода) Тогда
		ПерейтиПоНавигационнойСсылке(СсылкаДляПерехода);
	КонецЕсли;
КонецПроцедуры

// БоР :  04.08.2013 4:20:08
Функция ПолучитьУИСсылки(Ссылка) Экспорт
	ВозВрат БоР_ОбщийМодуль.ПолучитьУИСсылки(Ссылка);
КонецФункции

// БоР : Функция вызывает диалог выбора файла для открытия 06.01.2007 17:48:20
Функция ВыбратьФайлДляОткрытия(НачальноеИмя, ПолученноеИмя, Фильтр, ОбъектФайл = Неопределено, ПроверятьСуществованиеФайла = Ложь) Экспорт
	
	ВыборФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);
	ВыборФайла.Фильтр = Фильтр;
	ВыборФайла.ПроверятьСуществованиеФайла = ПроверятьСуществованиеФайла;
	ВыборФайла.ПолноеИмяФайла = НачальноеИмя;
	Если НЕ ВыборФайла.Выбрать() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ОбъектФайл = Новый Файл(НачальноеИмя);
	ПолученноеИмя = ВыборФайла.ПолноеИмяФайла;
	Возврат Истина;
	
КонецФункции // ВыбратьФайл() Экспорт

// БоР : Функция вызывает диалог выбора файла для открытия 06.01.2007 17:55:44
Функция ВыбратьФайлДляСохранения(НачальноеИмя, ПолученноеИмя, Фильтр, ОбъектФайл = Неопределено) Экспорт
	
	ВыборФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Сохранение);
	ВыборФайла.Фильтр = Фильтр;
	ВыборФайла.ПолноеИмяФайла = НачальноеИмя;
	Если НЕ ВыборФайла.Выбрать() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ОбъектФайл = Новый Файл(НачальноеИмя);
	ПолученноеИмя = ВыборФайла.ПолноеИмяФайла;
	Возврат Истина;
КонецФункции // ВыбратьФайлДляСохранения(НачальноеИмя,Фильтр) Экспорт

// БоР : Функция вызывает диалог выбора каталога 06.01.2007 17:57:24
Функция ВыбратьКаталогНаДиске(НачальноеИмя, ПолученноеИмя, ОбъектФайл = Неопределено) Экспорт
	
	ВыборФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.ВыборКаталога);
	ВыборФайла.Каталог = НачальноеИмя;
	Если НЕ ВыборФайла.Выбрать() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ОбъектФайл = Новый Файл(НачальноеИмя);
	ПолученноеИмя = ВыборФайла.Каталог;
	Возврат Истина;
	
КонецФункции // ВыбратьКаталог(НачальноеИмя) Экспорт

// БоР :  11.02.2014 1:44:45
Процедура ВыполнитьРасшифровкуОтчета(ИмяОтчета, ИмяМакета, УникальныйИдентификатор, ДанныеРасшифровки, Расшифровка) Экспорт
	
	АдресСхемыКомпоновки = БоР_ОбщийМодуль.ПолучитьСхемуКомпоновкиОтчета(ИмяОтчета, ИмяМакета, УникальныйИдентификатор);
	
	ОбработкаРасшифровки = Новый ОбработкаРасшифровкиКомпоновкиДанных(ДанныеРасшифровки, Новый ИсточникДоступныхНастроекКомпоновкиДанных(АдресСхемыКомпоновки));
	ДополнительныеПараметры = Новый Структура;
	ДополнительныеПараметры.Вставить("ДанныеРасшифровки"			, ДанныеРасшифровки);
	ДополнительныеПараметры.Вставить("ИмяОтчета"					, ИмяОтчета);
	ДополнительныеПараметры.Вставить("Расшифровка"					, Расшифровка);
	ОписаниеОповещения = Новый ОписаниеОповещения("ВыполнитьРасшифровкуОтчетаЗавершение", БоР_ОбщийМодульКлиент, ДополнительныеПараметры);
	ОбработкаРасшифровки.ПоказатьВыборДействия(ОписаниеОповещения, Расшифровка, , , Истина, );
	
КонецПроцедуры

Процедура ВыполнитьРасшифровкуОтчетаЗавершение(ВыбранноеДействие, ПараметрыВыбранногоДействия, ДополнительныеПараметры) Экспорт
    
    ДанныеРасшифровки	= ДополнительныеПараметры.ДанныеРасшифровки;
    ИмяОтчета			= ДополнительныеПараметры.ИмяОтчета;
    Расшифровка			= ДополнительныеПараметры.Расшифровка;
    
    Если ВыбранноеДействие = ДействиеОбработкиРасшифровкиКомпоновкиДанных.Нет Тогда
        ВозВрат;
    ИначеЕсли ВыбранноеДействие = ДействиеОбработкиРасшифровкиКомпоновкиДанных.ОткрытьЗначение Тогда
        ПоказатьЗначение(Неопределено, ПараметрыВыбранногоДействия) 
    Иначе
        ОписаниеРасшифровки = Новый ОписаниеОбработкиРасшифровкиКомпоновкиДанных(ДанныеРасшифровки, Расшифровка, ПараметрыВыбранногоДействия);
        
        ПараметрыФормы = Новый Структура;
        ПараметрыФормы.Вставить("СформироватьПриОткрытии"	, Истина);
        ПараметрыФормы.Вставить("Расшифровка"				, ОписаниеРасшифровки);
        ОткрытьФорму("Отчет." + ИмяОтчета + ".ФормаОбъекта", ПараметрыФормы, , Истина);
    КонецЕсли;

КонецПроцедуры

Функция ПолучитьПустойОбработчикОповещений() Экспорт

	#Если Не ТолстыйКлиентОбычноеПриложение Тогда
		ВозВрат Новый ОписаниеОповещения("ПолучитьПустойОбработчикОповещений_Выполнить",);
	#Иначе
		ВозВрат Неопределено;
	#КонецЕсли

КонецФункции // ()

Процедура ПолучитьПустойОбработчикОповещений_Выполнить(КодВозврата, ДополнительныеПараметры) Экспорт
	// Заглушка для асинхронных вызовов
КонецПроцедуры
