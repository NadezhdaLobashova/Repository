
// Возвращаент копию переданной структуры данных.
// Честно скопировано из какого-то то общего модуля
Функция СкопироватьСтруктуруДанных(КоллекцияИсходная) Экспорт
	
	ТипЗначения = ТипЗнч(КоллекцияИсходная);
	Если ТипЗначения = Тип("Структура") Тогда
		КоллекцияКопия = Новый Структура;
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			КоллекцияКопия.Вставить(Элемент.Ключ, СкопироватьСтруктуруДанных(Элемент.Значение));
		КонецЦикла;
		Возврат КоллекцияКопия; 
	#Если Не Клиент Тогда
	ИначеЕсли ТипЗначения = Тип("ТаблицаЗначений") Тогда
		Возврат КоллекцияИсходная.Скопировать();
	ИначеЕсли ТипЗначения = Тип("ДеревоЗначений") Тогда
		Возврат КоллекцияИсходная.Скопировать();
	ИначеЕсли ТипЗначения = Тип("СписокЗначений") Тогда
		Возврат КоллекцияИсходная.Скопировать();
	#КонецЕсли
	ИначеЕсли ТипЗначения = Тип("Массив") Тогда
		КоллекцияКопия = Новый Массив;
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			КоллекцияКопия.Добавить(СкопироватьСтруктуруДанных(Элемент));
		КонецЦикла;
		Возврат КоллекцияКопия;
	ИначеЕсли ТипЗначения = Тип("Соответствие") Тогда
		КоллекцияКопия = Новый Соответствие;
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			КоллекцияКопия.Вставить(Элемент.Ключ, СкопироватьСтруктуруДанных(Элемент.Значение));
		КонецЦикла;
		Возврат КоллекцияКопия;
	Иначе
		Возврат КоллекцияИсходная
	КонецЕсли;
	
КонецФункции

// БоР : Сранивает поля КонтрольнаяСтруктура с аналогичными полями ПроверяемоеЗначение 18.07.2017 16:26:23
Функция СравнитьПоляСтруктур(КонтрольнаяСтруктура, ПроверяемоеЗначение) Экспорт
	Для каждого Поле Из КонтрольнаяСтруктура Цикл
		Если Поле.Значение <> ПроверяемоеЗначение[Поле.Ключ] Тогда
			ВозВрат Ложь;
		КонецЕсли;
	КонецЦикла;
	ВозВрат Истина;
КонецФункции

#Область СКД_Отборы_Всякое_близкое

// БоР : Находит и возвращает все элементы отбора (только в линейной структуре, не учитывая содержимое групп) 09.05.2012 15:06:48
Функция НайтиЭлементыОтбора(ЭлементСтруктуры, ПолеОтбора, ВидСравнения = Неопределено, ЗначениеОтбора = Неопределено, Использование = Неопределено, Представление = Неопределено) Экспорт
	
	Если ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппировкаКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ТаблицаКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ДиаграммаКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Настройки.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Настройки.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ОтборКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры;
	Иначе// предполагаем, что это что-то, у чего есть поле "Отбор"
		Отбор = ЭлементСтруктуры.Отбор;
	КонецЕсли;
	
	Если ТипЗнч(ПолеОтбора) = Тип("Строка") Тогда
		ПолеОтбора = Новый ПолеКомпоновкиДанных(ПолеОтбора);
	КонецЕсли;
	
	МассивЭлементовОтбора = Новый Массив;
	Для каждого ЭлементОтбора Из Отбор.Элементы Цикл
		Если ТипЗнч(ЭлементОтбора) <> Тип("ЭлементОтбораКомпоновкиДанных") Тогда
			// группы элементов ищем только по представлению
			Если Представление <> Неопределено И ЭлементОтбора.Представление = Представление Тогда
				МассивЭлементовОтбора.Добавить(ЭлементОтбора);
				Продолжить;
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		Если ВидСравнения <> Неопределено И ЭлементОтбора.ВидСравнения <> ВидСравнения Тогда
			Продолжить;
		КонецЕсли;
		Если Представление <> Неопределено И ЭлементОтбора.Представление <> Представление Тогда
			Продолжить;
		КонецЕсли;
		Если Использование <> Неопределено И ЭлементОтбора.Использование <> Использование Тогда
			Продолжить;
		КонецЕсли;
		Если ЗначенияРавны(ЭлементОтбора.ЛевоеЗначение, ПолеОтбора) И (ЗначениеОтбора = Неопределено ИЛИ ЗначенияРавны(ЭлементОтбора.ПравоеЗначение, ЗначениеОтбора)) Тогда
			МассивЭлементовОтбора.Добавить(ЭлементОтбора);
			Продолжить;
		КонецЕсли;
		Если (ЗначениеОтбора = Неопределено ИЛИ ЗначенияРавны(ЭлементОтбора.ЛевоеЗначение, ЗначениеОтбора)) И ЗначенияРавны(ЭлементОтбора.ПравоеЗначение, ПолеОтбора) Тогда
			МассивЭлементовОтбора.Добавить(ЭлементОтбора);
			Продолжить;
		КонецЕсли;
	КонецЦикла;
	ВозВрат МассивЭлементовОтбора;
	
КонецФункции // ПолучитьЭлементОтбора()

// БоР : Добавляет в отбор элемент отбора по определенному полю 09.07.2009 14:01:22
Функция ДобавитьЭлементОтбора(ЭлементСтруктуры, ПолеОтбора, ВидСравнения = Неопределено, ЗначениеОтбора = Неопределено, УдалятьСуществующие = Истина, Использование = Истина, Представление = Неопределено, ПользовательскаяНастройка = Ложь) Экспорт
	
	Если ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппировкаКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ТаблицаКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ДиаграммаКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Настройки.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Настройки.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ОтборКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры;
	Иначе// предполагаем, что это что-то, у чего есть поле "Отбор"
		Отбор = ЭлементСтруктуры.Отбор;
	КонецЕсли;
	
	Если ТипЗнч(ПолеОтбора) = Тип("Строка") Тогда
		ПолеОтбора = Новый ПолеКомпоновкиДанных(ПолеОтбора);
	КонецЕсли;
	
	Если ВидСравнения = Неопределено Тогда
		ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	КонецЕсли;
	
	Если УдалятьСуществующие Тогда
		МассивЭлементовОтбора = НайтиЭлементыОтбора(Отбор, ПолеОтбора, , , , Представление);
		Для каждого ЭлементОтбора Из МассивЭлементовОтбора Цикл
			Отбор.Элементы.Удалить(ЭлементОтбора);
		КонецЦикла;
	КонецЕсли;
	
	НовыйЭлементОтбора = Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	НовыйЭлементОтбора.Использование  = Использование;
	НовыйЭлементОтбора.ВидСравнения   = ВидСравнения;
	НовыйЭлементОтбора.ЛевоеЗначение  = ПолеОтбора;
	НовыйЭлементОтбора.ПравоеЗначение = ЗначениеОтбора;
	НовыйЭлементОтбора.Представление  = Представление;
	Если ПользовательскаяНастройка <> Ложь Тогда
		НовыйЭлементОтбора.ИдентификаторПользовательскойНастройки = ?(ПользовательскаяНастройка = Истина, Строка(Новый УникальныйИдентификатор), ПользовательскаяНастройка);
	КонецЕсли;
	ВозВрат НовыйЭлементОтбора;
КонецФункции // ДобавитьЭлементОтбора()

// БоР :  21.07.2017 14:02:58
Функция УдалитьЭлементОтбора(ЭлементСтруктуры, ПолеОтбора, Представление = Неопределено) Экспорт
	
	Если ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппировкаКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ТаблицаКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ДиаграммаКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Настройки.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Настройки.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ОтборКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры;
	Иначе// предполагаем, что это что-то, у чего есть поле "Отбор"
		Отбор = ЭлементСтруктуры.Отбор;
	КонецЕсли;
	
	Если ТипЗнч(ПолеОтбора) = Тип("Строка") Тогда
		ПолеОтбора = Новый ПолеКомпоновкиДанных(ПолеОтбора);
	КонецЕсли;
	
	МассивЭлементовОтбора = НайтиЭлементыОтбора(Отбор, ПолеОтбора, , , , Представление);
	Для каждого ЭлементОтбора Из МассивЭлементовОтбора Цикл
		Отбор.Элементы.Удалить(ЭлементОтбора);
	КонецЦикла;
	
	ВозВрат Неопределено;
	
КонецФункции

// БоР :  21.07.2017 14:02:58
Функция УстановитьОтборПоПолю(ЭлементСтруктуры, Поле, Значение, ПользовательскаяНастройка = Ложь, Представление = "", ВидСравнения = Неопределено, УстанавливатьОтбор = Истина) Экспорт
	Если Не ЗначениеЗаполнено(Значение) Тогда
		ЭлементОтбора = УдалитьЭлементОтбора(ЭлементСтруктуры, Поле, ?(Представление = "", "Отбор по полю " + Поле, Представление));
	Иначе
		ЭлементОтбора = ДобавитьЭлементОтбора(ЭлементСтруктуры, Поле, ?(ВидСравнения = Неопределено, ВидСравненияКомпоновкиДанных.Равно, ВидСравнения), Значение, Истина, УстанавливатьОтбор, ?(Представление = "", "Отбор по полю " + Поле, Представление), ПользовательскаяНастройка);
	КонецЕсли;
	ВозВрат ЭлементОтбора;
КонецФункции

// БоР : Добавляет в отбор элемент отбора по определенному полю 09.07.2009 14:01:22
Функция ДобавитьГруппуОтбора(ЭлементСтруктуры, ТипГруппы, УдалятьСуществующие = Истина, Использование = Истина, Представление = Неопределено, ПользовательскаяНастройка = Ложь) Экспорт
	
	Если ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппировкаКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ТаблицаКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ДиаграммаКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Настройки.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Настройки.Отбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ОтборКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры;
	Иначе// предполагаем, что это что-то, у чего есть поле "Отбор"
		Отбор = ЭлементСтруктуры.Отбор;
	КонецЕсли;
	
	Если УдалятьСуществующие Тогда
		МассивЭлементовОтбора = НайтиЭлементыОтбора(Отбор, , , , , Представление);
		Для каждого ЭлементОтбора Из МассивЭлементовОтбора Цикл
			Отбор.Элементы.Удалить(ЭлементОтбора);
		КонецЦикла;
	КонецЕсли;
	
	НовыйЭлементОтбора = Отбор.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
	НовыйЭлементОтбора.Использование	= Использование;
	НовыйЭлементОтбора.ТипГруппы		= ТипГруппы;
	НовыйЭлементОтбора.Представление	= Представление;
	Если ПользовательскаяНастройка <> Ложь Тогда
		НовыйЭлементОтбора.ИдентификаторПользовательскойНастройки = ?(ПользовательскаяНастройка = Истина, Строка(Новый УникальныйИдентификатор), ПользовательскаяНастройка);
	КонецЕсли;
	ВозВрат НовыйЭлементОтбора;
КонецФункции // ДобавитьЭлементОтбора()

// БоР : Настраивает параметры данных компоновщика (те что с "&") 04.10.2009 21:39:59
Процедура НастроитьПараметрыДанныхКомпоновки(Объект, СтруктураПараметров, ПользовательскаяНастройка = Ложь) Экспорт
	Если ТипЗнч(Объект) = Тип("НастройкиКомпоновкиДанных") Тогда
		Настройки = Объект;
	ИначеЕсли ТипЗнч(Объект) = Тип("ГруппировкаКомпоновкиДанных") Тогда
		Настройки = Объект;
	ИначеЕсли ТипЗнч(Объект) = Тип("ТаблицаКомпоновкиДанных") Тогда
		Настройки = Объект;
	ИначеЕсли ТипЗнч(Объект) = Тип("ДиаграммаКомпоновкиДанных") Тогда
		Настройки = Объект;
	ИначеЕсли ТипЗнч(Объект) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
		Настройки = Объект.Настройки;
	Иначе// предполагаем, что это отчет или что-то подобное, у чего есть поле "КомпоновщикНастроек"
		Настройки = Объект.КомпоновщикНастроек.Настройки;
	КонецЕсли;
	Для каждого Параметр Из СтруктураПараметров Цикл
		Если Настройки.ПараметрыДанных.ДоступныеПараметры <> Неопределено Тогда
			Если Настройки.ПараметрыДанных.ДоступныеПараметры.Элементы.Найти(Параметр.Ключ) = Неопределено Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		НовыйПараметр = Настройки.ПараметрыДанных.Элементы.Найти(Параметр.Ключ);
		Если НовыйПараметр = Неопределено Тогда
			НовыйПараметр = Настройки.ПараметрыДанных.Элементы.Добавить();
			НовыйПараметр.Параметр      = Новый ПараметрКомпоновкиДанных(Параметр.Ключ);
		КонецЕсли;
		НовыйПараметр.Использование = Истина;
		НовыйПараметр.Значение      = Параметр.Значение;
		Если ПользовательскаяНастройка <> Ложь Тогда
			НовыйПараметр.ИдентификаторПользовательскойНастройки = ?(ПользовательскаяНастройка = Истина, Строка(Новый УникальныйИдентификатор), ПользовательскаяНастройка);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// БоР : Извлекает параметры данных компоновщика (из тех что с "&") 04.10.2009 21:39:59
функция ПолучитьПараметрыДанныхКомпоновки(Объект) Экспорт
	Если ТипЗнч(Объект) = Тип("НастройкиКомпоновкиДанных") Тогда
		Настройки = Объект;
	ИначеЕсли ТипЗнч(Объект) = Тип("ГруппировкаКомпоновкиДанных") Тогда
		Настройки = Объект;
	ИначеЕсли ТипЗнч(Объект) = Тип("ТаблицаКомпоновкиДанных") Тогда
		Настройки = Объект;
	ИначеЕсли ТипЗнч(Объект) = Тип("ДиаграммаКомпоновкиДанных") Тогда
		Настройки = Объект;
	ИначеЕсли ТипЗнч(Объект) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
		Настройки = Объект.Настройки;
	Иначе// предполагаем, что это отчет или что-то подобное, у чего есть поле "КомпоновщикНастроек"
		Настройки = Объект.КомпоновщикНастроек.Настройки;
	КонецЕсли;
	СтруктураПараметров = Новый Структура;
	Для каждого Параметр Из Настройки.ПараметрыДанных.Элементы Цикл
		СтруктураПараметров.Вставить(Параметр.Параметр, Параметр.Значение);
	КонецЦикла;
	ВозВрат СтруктураПараметров;
КонецФункции

// БоР : Извлекает параметр данных компоновщика (из тех что с "&") 04.10.2009 21:39:59
Функция ПолучитьПараметрДанныхКомпоновки(Объект, ИмяПараметра) Экспорт
	СтруктураПараметров = ПолучитьПараметрыДанныхКомпоновки(Объект);
	ЗначениеПараметра = Неопределено;
	СтруктураПараметров.Свойство(ИмяПараметра, ЗначениеПараметра);
	ВозВрат ЗначениеПараметра;
КонецФункции

// БоР : Находит элементы условного оформления по представлению 11.09.2015 2:39:24
Функция НайтиЭлементыУсловногоОформления(УсловноеОформление, Представление) Экспорт
	ЭлементыУО = Новый Массив;
	Для каждого ОчереднойЭлементУО Из УсловноеОформление.Элементы Цикл
		Если ОчереднойЭлементУО.Представление = Представление Тогда
			ЭлементыУО.Добавить(ОчереднойЭлементУО);
		КонецЕсли;
	КонецЦикла;
	ВозВрат ЭлементыУО;
КонецФункции

// БоР : 11.09.2015 2:39:24
Функция ДобавитьЭлементУсловногоОформления(УсловноеОформление, Представление = Неопределено, УдалятьСуществующие = Истина, Использование = Истина, ПользовательскаяНастройка = Ложь) Экспорт
	Если УдалятьСуществующие Тогда
		ЭлементыУО = НайтиЭлементыУсловногоОформления(УсловноеОформление, Представление);
		Для каждого ЭлементУО Из ЭлементыУО Цикл
			УсловноеОформление.Элементы.Удалить(ЭлементУО);
		КонецЦикла;
	КонецЕсли;
	
	ЭлементУО = УсловноеОформление.Элементы.Добавить();
	ЭлементУО.Использование = Использование;
	ЭлементУО.Представление = Представление;
	Если ПользовательскаяНастройка <> Ложь Тогда
		ЭлементУО.ИдентификаторПользовательскойНастройки = ?(ПользовательскаяНастройка = Истина, Строка(Новый УникальныйИдентификатор), ПользовательскаяНастройка);
	КонецЕсли;
		
	ВозВрат ЭлементУО;
КонецФункции

// БоР : 11.09.2015 2:39:24
Функция ДобавитьПолеВЭлементУО(ЭлементУО, ИмяПоля) Экспорт
	ПолеОформления = ЭлементУО.Поля.Элементы.Добавить();
	ПолеОформления.Поле = Новый ПолеКомпоновкиДанных(ИмяПоля);
	ВозВрат ПолеОформления;
КонецФункции

// БоР : 11.09.2015 2:39:24
Процедура ДобавитьОформлениеВЭлементУО(ЭлементУО, ИмяПараметра, ЗначениеПараметра) Экспорт
	ЭлементУО.Оформление.УстановитьЗначениеПараметра(ИмяПараметра, ЗначениеПараметра);
КонецПроцедуры
#КонецОбласти

// БоР :  04.05.2016 0:50:54
Процедура ДополнитьСтруктуру(СтруктураКуда, СтруктураОткуда) Экспорт
	// БоР : пока возложим проврки на вызываюший контекст 04.05.2016 0:52:21
	//Если ТипЗнч(СтруктураКуда) <> Тип("Структура") Тогда
	//	ВозВрат;
	//КонецЕсли;
	//Если ТипЗнч(СтруктураОткуда) <> Тип("Структура") Тогда
	//	ВозВрат;
	//КонецЕсли;
	Для каждого Значение Из СтруктураОткуда Цикл
		СтруктураКуда.Вставить(Значение.Ключ, Значение.Значение);
	КонецЦикла;
КонецПроцедуры

// БоР : Получает строки из ТЧ по идентификаторам - в основном для ВыделенныеСтроки в форме 28.09.2015 17:56:01
Функция ПолучитьСтрокиПоИдентификаторам(ТабличнаяЧасть, МассивИдентификаторов) Экспорт
	МассивСтрок = Новый Массив;
	Для каждого ИдентификаторСтроки Из МассивИдентификаторов Цикл
		СтрокаТЧ = ТабличнаяЧасть.НайтиПоИдентификатору(ИдентификаторСтроки);
		Если СтрокаТЧ <> Неопределено Тогда
			МассивСтрок.Добавить(СтрокаТЧ);
		КонецЕсли;
	КонецЦикла;
	ВозВрат МассивСтрок;
КонецФункции

// БоР : Находит первую строку в таблице (ТЗ, или таблицы формы) по ключу, если она есть - для поиска уникальных строк 16.09.2015 16:37:56
Функция НайтиСтрокуТаблицы(Таблица, Ключ, СтрокаУникальна = Неопределено) Экспорт

	СтрокиИсточника = Таблица.НайтиСтроки(Ключ);
	Если СтрокиИсточника.Количество() > 0 Тогда
		СтрокаУникальна = СтрокиИсточника.Количество() > 1;
		ВозВрат СтрокиИсточника[0];
	Иначе
		СтрокаУникальна = Неопределено;
		ВозВрат Неопределено;
	КонецЕсли;
	
КонецФункции

// БоР : получение поля из структуры 26.09.2016 02:06:33
Функция ПолучитьПолеСтруктуры(КакаяТоСтруктура, ИмяПоля, ЗначениеПоУмолчанию = Неопределено) Экспорт
	
	Если КакаяТоСтруктура.Свойство(ИмяПоля) Тогда
		ВозВрат КакаяТоСтруктура[ИмяПоля];
	Иначе
		ВозВрат ЗначениеПоУмолчанию;
	КонецЕсли;
	
КонецФункции

// БоР : получение параметра из структуры, используемой обычно в параметрах выбора формы/поля 21.08.2013 4:54:10
Функция ПолучитьПараметрВыбора(ПараметрыВыбора, ИмяПараметра) Экспорт
	
	Если ПараметрыВыбора.Свойство(ИмяПараметра) Тогда
		ВозВрат ПараметрыВыбора[ИмяПараметра];
	ИначеЕсли ПараметрыВыбора.Свойство("Отбор") И ПараметрыВыбора.Отбор.Свойство(ИмяПараметра) Тогда
		ВозВрат ПараметрыВыбора.Отбор[ИмяПараметра];
	Иначе
		ВозВрат Неопределено;
	КонецЕсли;
	
КонецФункции

// БоР : Сравнивает значения, в том числе и содержимое списков (без учета сортировки) 09.05.2012 15:10:38
Функция ЗначенияРавны(Значение1, Значение2) Экспорт
	
	Если ТипЗнч(Значение1) <> ТипЗнч(Значение2) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипЗнч(Значение1) = Тип("СписокЗначений") Тогда
		Если Значение1.Количество() <> Значение2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого Элемент1 Из Значение1 Цикл
			Для каждого Элемент2 Из Значение2 Цикл
				Если ЗначенияРавны(Элемент1.Значение, Элемент2.Значение) Тогда
					Найден = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Не Найден Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Для каждого Элемент2 Из Значение2 Цикл
			Для каждого Элемент1 Из Значение1 Цикл
				Если ЗначенияРавны(Элемент2.Значение, Элемент1.Значение) Тогда
					Найден = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Не Найден Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
	ИначеЕсли ТипЗнч(Значение1) = Тип("Массив") Тогда
		Если Значение1.Количество() <> Значение2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого Элемент1 Из Значение1 Цикл
			Для каждого Элемент2 Из Значение2 Цикл
				Если ЗначенияРавны(Элемент1, Элемент2) Тогда
					Найден = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Не Найден Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Для каждого Элемент2 Из Значение2 Цикл
			Для каждого Элемент1 Из Значение1 Цикл
				Если ЗначенияРавны(Элемент2, Элемент1) Тогда
					Найден = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Не Найден Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
	ИначеЕсли ТипЗнч(Значение1) = Тип("Структура") Тогда
		Если Значение1.Количество() <> Значение2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		Для каждого Элемент1 Из Значение1 Цикл
			ТекущееЗначение = Неопределено;
			Если НЕ Значение2.Свойство(Элемент1.Ключ, ТекущееЗначение) Тогда
				Возврат Ложь;
			КонецЕсли;
			Если Не ЗначенияРавны(Значение1.Значение, ТекущееЗначение) Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		Возврат Истина;
	Иначе
		Возврат Значение1 = Значение2;
	КонецЕсли;
	Возврат Ложь;
	
КонецФункции

// БоР : Устанавливает проверку незаполненности реквизитов на форме 03.05.2009 13:28:38
Процедура НастроитьОбязательностьРеквизита(Элемент, Обязательность, Значение) Экспорт
	ЗначениеЗаполнено = ЗначениеЗаполнено(Значение);
	//Если ТипЗнч(Элемент) = Тип("ПолеФормы") И Элемент.Вид = ВидПоляФормы.ПолеВвода Тогда
	//	Элемент.АвтоВыборНезаполненного   = Обязательность;
	//КонецЕсли; // должно устанавливаться автоматически, если "Авто"
	Если ТипЗнч(Элемент) = Тип("ПолеФормы") ИЛИ ТипЗнч(Элемент) = Тип("ТаблицаФормы") Тогда
		ОбязательностьЗаполнения	= ?(ТипЗнч(Обязательность) = Тип("Булево"), Обязательность, ЛОЖЬ);
		Элемент.АвтоОтметкаНезаполненного = ОбязательностьЗаполнения;
		Если Не ЗначениеЗаполнено Тогда
			Элемент.ОтметкаНезаполненного = ОбязательностьЗаполнения;
		КонецЕсли;
	КонецЕсли; 
КонецПроцедуры

Функция ПолучитьРеквизитыФормы(ИсключаемыеРеквизиты) Экспорт
	ВозВрат Бор_ПовторноеИспользованиеСервер.ПолучитьДоступностьРолей();
КонецФункции

Процедура УстановитьДоступностьЭлементов(Элементы, Доступность) Экспорт
	Не_Доступность = Не Доступность; // обход ошибки синтаксического анализатора
	Если ТипЗнч(Элементы) = Тип("ГруппаФормы") Тогда
		Если Элементы.ТолькоПросмотр <> Не_Доступность Тогда
			Элементы.ТолькоПросмотр = Не Доступность;
		КонецЕсли;
		Для каждого Поле Из Элементы.ПодчиненныеЭлементы Цикл
			УстановитьДоступностьЭлементов(Поле, Доступность)
		КонецЦикла;
	ИначеЕсли ТипЗнч(Элементы) = Тип("УправляемаяФорма") Тогда
		Для каждого Поле Из Элементы.ПодчиненныеЭлементы Цикл
			УстановитьДоступностьЭлементов(Поле, Доступность)
		КонецЦикла;
	ИначеЕсли ТипЗнч(Элементы) = Тип("ЭлементыФормы") Тогда
		Для каждого Поле Из Элементы Цикл
			УстановитьДоступностьЭлементов(Поле, Доступность)
		КонецЦикла;
	ИначеЕсли ТипЗнч(Элементы) = Тип("ВсеЭлементыФормы") Тогда
		Для каждого Поле Из Элементы Цикл
			УстановитьДоступностьЭлементов(Поле, Доступность)
		КонецЦикла;
	ИначеЕсли ТипЗнч(Элементы) = Тип("ТаблицаФормы") Тогда
		Если Элементы.ТолькоПросмотр <> Не_Доступность Тогда
			Элементы.ТолькоПросмотр = Не Доступность;
		КонецЕсли;
		Если Элементы.Доступность <> Доступность Тогда
			Элементы.Доступность = Доступность;
		КонецЕсли;
		Для каждого Поле Из Элементы.ПодчиненныеЭлементы Цикл
			УстановитьДоступностьЭлементов(Поле, Доступность)
		КонецЦикла;
	ИначеЕсли ТипЗнч(Элементы) = Тип("КнопкаФормы") Тогда
		Если Элементы.Доступность <> Доступность Тогда
			Элементы.Доступность = Доступность;
		КонецЕсли;
	ИначеЕсли ТипЗнч(Элементы) = Тип("ДекорацияФормы") Тогда
		Попытка
			Если Элементы.Доступность <> Доступность Тогда
				Элементы.Доступность = Доступность;
			КонецЕсли;
		Исключение
			// видимо, это расширенная подсказка. Как ее отличить по-другому, неизвестно
		КонецПопытки;
	ИначеЕсли ТипЗнч(Элементы) = Тип("ДополнениеЭлементаФормы") Тогда
		Если Элементы.Доступность <> Доступность Тогда
			Элементы.Доступность = Доступность;
		КонецЕсли;
	Иначе
		Попытка
			Если Элементы.ТолькоПросмотр <> Не_Доступность Тогда
				Элементы.ТолькоПросмотр = Не Доступность;
			КонецЕсли;
		Исключение
		КонецПопытки;
	КонецЕсли;
КонецПроцедуры

Процедура УстановитьВидПолеВводаИлиНадпись(Элементы, УстановитьПолеВвода, ИзменитьСтиль = Ложь, УстановитьГиперссылку = Ложь) Экспорт
	Если ТипЗнч(Элементы) = Тип("ГруппаФормы") Тогда
		Для каждого Поле Из Элементы.ПодчиненныеЭлементы Цикл
			УстановитьВидПолеВводаИлиНадпись(Поле, УстановитьПолеВвода)
		КонецЦикла;
	ИначеЕсли ТипЗнч(Элементы) = Тип("УправляемаяФорма") Тогда
		Для каждого Поле Из Элементы.ПодчиненныеЭлементы Цикл
			УстановитьВидПолеВводаИлиНадпись(Поле, УстановитьПолеВвода)
		КонецЦикла;
	ИначеЕсли ТипЗнч(Элементы) = Тип("ЭлементыФормы") Тогда
		Для каждого Поле Из Элементы Цикл
			УстановитьВидПолеВводаИлиНадпись(Поле, УстановитьПолеВвода)
		КонецЦикла;
	ИначеЕсли ТипЗнч(Элементы) = Тип("ВсеЭлементыФормы") Тогда
		Для каждого Поле Из Элементы Цикл
			УстановитьВидПолеВводаИлиНадпись(Поле, УстановитьПолеВвода)
		КонецЦикла;
	ИначеЕсли ТипЗнч(Элементы) = Тип("ТаблицаФормы") Тогда
		Для каждого Поле Из Элементы.ПодчиненныеЭлементы Цикл
			УстановитьВидПолеВводаИлиНадпись(Поле, УстановитьПолеВвода)
		КонецЦикла;
	ИначеЕсли ТипЗнч(Элементы) = Тип("ПолеФормы") Тогда
		Если Элементы.Вид = ВидПоляФормы.ПолеНадписи И УстановитьПолеВвода Тогда
			Элементы.Вид = ВидПоляФормы.ПолеВвода;
			Если ИзменитьСтиль Тогда
				Элементы.Шрифт = Новый Шрифт(Элементы.Шрифт, , , Ложь);
				Элементы.ЦветТекста = Новый Цвет;
			КонецЕсли;
		ИначеЕсли Элементы.Вид = ВидПоляФормы.ПолеВвода И Не УстановитьПолеВвода Тогда
			Элементы.Вид = ВидПоляФормы.ПолеНадписи;
			Элементы.Гиперссылка = УстановитьГиперссылку;
			Если ИзменитьСтиль Тогда
				Элементы.Шрифт = Новый Шрифт(Элементы.Шрифт, , , Истина);
				Элементы.ЦветТекста = Бор_ПовторноеИспользованиеКлиентСервер.ПолучитьЦветСтиля("ЗеленыйЦветНадписиФормы");
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

// БоР :  01.10.2014 2:28:36
Функция УстановитьКоличествоПервыхЗапроса(ТекстЗапроса, Знач Ограничение) Экспорт
	Ограничение = ВЧисло(Ограничение);
	Если Ограничение > 0 Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ВЫБРАТЬ ПЕРВЫЕ 1000", "ВЫБРАТЬ ПЕРВЫЕ " + Формат(Ограничение, "ЧГ="));
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ВЫБРАТЬ ПЕРВЫЕ 1000", "ВЫБРАТЬ");
	КонецЕсли;
	Если Ограничение > 0 Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ВЫБРАТЬ РАЗЛИЧНЫЕ ПЕРВЫЕ 1000", "ВЫБРАТЬ РАЗЛИЧНЫЕ ПЕРВЫЕ " + Формат(Ограничение, "ЧГ="));
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ВЫБРАТЬ РАЗЛИЧНЫЕ ПЕРВЫЕ 1000", "ВЫБРАТЬ РАЗЛИЧНЫЕ");
	КонецЕсли;
	
	ВозВрат ТекстЗапроса;
КонецФункции

#Область Читы_Присвоить_Выполнить_Вычислить
// БоР : Присваивает из одной переменной в другую 25.05.2009 5:31:38
Функция Присвоить(Куда, Что) Экспорт
	Куда = Что;
	ВозВрат Куда;
КонецФункции // Присвоить(Куда, Что)

// БоР : Выполняет кусок кода 25.05.2009 5:31:38
Функция ВыполнитьКод(Что) Экспорт
	Выполнить(Что);
	ВозВрат Истина;
КонецФункции

// БоР : Вычисляет выражение. Можно использовать например при COM-соединении 25.05.2009 5:31:38
Функция ВычислитьВыражение(Что) Экспорт
	ВозВрат Вычислить(Что);
КонецФункции
#КонецОбласти

#Область Приведение_типов
// БоР : Преобразовывает значение в булево 06.04.2011 3:22:23
Функция ВБулево(ПочтиБулево) Экспорт
	ТипБулево = Новый ОписаниеТипов("Булево");
	Если ТипЗнч(ПочтиБулево) = Тип("Строка") И Не ЕстьНеЦифры(ПочтиБулево) Тогда
		ВозВрат ТипБулево.ПривестиЗначение(ВЧисло(ПочтиБулево));
	Иначе
		ВозВрат ТипБулево.ПривестиЗначение(ПочтиБулево);
	КонецЕсли;
КонецФункции // ВЧисло()

// БоР : Преобразовывает значение в число 11.01.2010 0:19:23
Функция ВЧисло(ПочтиЧисло) Экспорт
	ТипЧисло = Новый ОписаниеТипов("Число",Новый КвалификаторыЧисла(0, 0, ДопустимыйЗнак.Любой));
	ВозВрат ТипЧисло.ПривестиЗначение(ПочтиЧисло);
КонецФункции // ВЧисло()

// БоР : Преобразовывает значение в дату 11.01.2010 0:19:23
Функция ВДату(Знач ПочтиДата) Экспорт
	Если ТипЗнч(ПочтиДата) = Тип("СтандартнаяДатаНачала") Тогда
		ПочтиДата = ПочтиДата.Дата;
	КонецЕсли;
	ТипДата = Новый ОписаниеТипов("Дата", , ,Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя));
	ВозВрат ТипДата.ПривестиЗначение(ПочтиДата);
КонецФункции // ВДату()

// БоР : Преобразует дату из дд.мм.гггг в дату 1С 07.01.2007 21:04:47
Функция ДатаИзСтроки(Знач ДатаСтрокой, Разделители = ".", Знач ПорядокСоставляющих = "ДМГчмс", ГодНачалаСтолетия = "30") Экспорт
	ПорядокСоставляющих = СокрЛП(ПорядокСоставляющих);
	ДатаСтрокойБыла = ДатаСтрокой;
	Если ПустаяСтрока(ДатаСтрокой) Тогда
		ВозВрат '0001-01-01';
	КонецЕсли;
	Если ТипЗнч(Разделители) = Тип("Строка") Тогда
		ДатаСтрокой = СтрЗаменить(ДатаСтрокой,Разделители,Символы.ПС);
	ИначеЕсли ТипЗнч(Разделители) = Тип("СписокЗначений") Тогда
		Для каждого Разделитель Из Разделители Цикл
			ДатаСтрокой = СтрЗаменить(ДатаСтрокой,Разделитель.Значение,Символы.ПС);
		КонецЦикла;
	ИначеЕсли ТипЗнч(Разделители) = Тип("Структура") Тогда
		Для каждого Разделитель Из Разделители Цикл
			ДатаСтрокой = СтрЗаменить(ДатаСтрокой,Разделитель.Значение,Символы.ПС);
		КонецЦикла;
	ИначеЕсли ТипЗнч(Разделители) = Тип("Соответствие") Тогда
		Для каждого Разделитель Из Разделители Цикл
			ДатаСтрокой = СтрЗаменить(ДатаСтрокой,Разделитель.Значение,Символы.ПС);
		КонецЦикла;
	Иначе
		ВозВрат '0001-01-01';
	КонецЕсли;
	Если СтрЧислоСтрок(ДатаСтрокой)<3 Тогда
		ВозВрат '0001-01-01';
	КонецЕсли; 
	ПозицияД = Найти(ПорядокСоставляющих,"Д");
	ПозицияМ = Найти(ПорядокСоставляющих,"М");
	ПозицияГ = Найти(ПорядокСоставляющих,"Г");
	Позиция_ч = Найти(ПорядокСоставляющих,"ч");
	Позиция_м = Найти(ПорядокСоставляющих,"м");
	Позиция_с = Найти(ПорядокСоставляющих,"с");
	
	ПозицияД = ?(ПозицияД = 0,1,ПозицияД);
	ПозицияМ = ?(ПозицияМ = 0,2,ПозицияМ);
	ПозицияГ = ?(ПозицияГ = 0,3,ПозицияГ);
	
	День  = СтрПолучитьСтроку(ДатаСтрокой,ПозицияД);
	Месяц = СтрПолучитьСтроку(ДатаСтрокой,ПозицияМ);
	Год   = СтрПолучитьСтроку(ДатаСтрокой,ПозицияГ);
	
	Если СтрДлина(Год) = 2 Тогда
		Если Год < ГодНачалаСтолетия Тогда
			Год = "20" + Год;
		Иначе
			Год = "19" + Год;
		КонецЕсли;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Позиция_ч) Тогда
		Часов = СтрПолучитьСтроку(ДатаСтрокой,Позиция_ч);
	Иначе
		Часов = "0";
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Позиция_м) Тогда
		Минут = СтрПолучитьСтроку(ДатаСтрокой,Позиция_м);
	Иначе
		Минут = "0";
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Позиция_с) Тогда
		Секунд = СтрПолучитьСтроку(ДатаСтрокой,Позиция_с);
	Иначе
		Секунд = "0";
	КонецЕсли;
	
	Попытка
		ВозВрат Дата(Год, Месяц, День, Часов, Минут, Секунд);
	Исключение
		//СообщитьИЗаписатьВЛог("Ошибка при преобразовании значения в дату : """+ДатаСтрокойБыла+"""!");
	КонецПопытки;
	
КонецФункции // ДатаИзСтроки(ДатаСой)

// БоР : Преобразование числа в строку добавлением ведущих нулей 08.02.2015 17:27:25
Функция ЧислоВСтрокуСВедущимиНулями(НачальноеЧисло, ДлинаСВедущимиНулями) Экспорт
	ЧислоЧислом = ВЧисло(НачальноеЧисло);
	ВозВрат Формат(ЧислоЧислом, "ЧЦ=" + ДлинаСВедущимиНулями + "; ЧН=; ЧВН=; ЧГ="); // строго говоря, надо бы ДлинаСВедущимиНулями избавить от "пробелов" в середине, но вряд ли будет число длиной 1000 символов
КонецФункции

// БоР : Преобразование числа в строку без пробелов и прочей шелухи 08.02.2015 17:27:25
Функция ЧислоВСтроку(НачальноеЧисло) Экспорт
	ЧислоЧислом = ВЧисло(НачальноеЧисло);
	ВозВрат Формат(ЧислоЧислом, "ЧН=; ЧГ=");
КонецФункции

// БоР : Удаляет из описания типов NULL, который образуется при получении данных из запроса 20.02.2017 15:37:17
Функция ТипБезNULL(ОписаниеТипаИсходное) Экспорт
	ОписаниеТипаНовое = Новый ОписаниеТипов(ОписаниеТипаИсходное, , "Null");
	ВозВрат ОписаниеТипаНовое;
КонецФункции

// БоР : Обертка для создания типа 20.02.2017 15:37:17
Функция ОписаниеТиповПоТипу(ТипЗначения) Экспорт
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(ТипЗначения);
	ОписаниеТипаНовое = Новый ОписаниеТипов(МассивТипов);
	ВозВрат ОписаниеТипаНовое;
КонецФункции
#КонецОбласти
 
#Область Обработка_строк
// БоР : Добавляет подстроку в строку (предположительно один символ). 02.09.2008 12:50:39
// БоР : может получиться строка длиннее заданной длины (если ДобавляемыйСимвол длиннее, чем один символ)
Функция ДобавитьСимволы(Знач СтрокаТекста, ДлинаРезультата, ДобавляемыйСимвол = " ", Слева = Истина, УбиратьСтарыеПробелы = Истина) Экспорт
	Если УбиратьСтарыеПробелы Тогда
		СтрокаТекста = СокрЛП(СтрокаТекста);
	КонецЕсли;
	ДлинаСтроки = СтрДлина(СтрокаТекста);
	Пока СтрДлина(СтрокаТекста) < ДлинаРезультата Цикл
		СтрокаТекста = ?(Слева,ДобавляемыйСимвол+СтрокаТекста,СтрокаТекста+ДобавляемыйСимвол);
	КонецЦикла;
	
	ВозВрат СтрокаТекста;
КонецФункции // ДобавитьСимволы()

// БоР : Разбирает одну строку на отдельныен слова в соответствии со списком разделителей  07.01.2007 1:20:05
Функция РазобратьСтрокуНаСлова(Знач СтрокаТекста, СписокРазделителей, ОставлятьПустыеСтроки = Ложь) Экспорт
	Для каждого Разделитель Из СписокРазделителей Цикл
		СтрокаТекста=СтрЗаменить(СтрокаТекста,Разделитель.Значение,Символы.ПС);
	КонецЦикла; 
	СЗ=Новый СписокЗначений();
	Для Н=1 По СтрЧислоСтрок(СтрокаТекста) Цикл
		ОчереднаяСтрока=СтрПолучитьСтроку(СтрокаТекста,Н);
		Если СокрЛП(ОчереднаяСтрока)<>"" ИЛИ ОставлятьПустыеСтроки Тогда
			СЗ.Добавить(СокрЛП(ОчереднаяСтрока));
		КонецЕсли;
	КонецЦикла;
	ВозВрат СЗ;
КонецФункции

// БоР : Разбирает одну строку на отдельныен слова в соответствии со списком разделителей 21.07.2017 17:20:06
Функция РазобратьСтрокуНаСловаНовая(Знач СтрокаТекста, Знач Разделители, ОставлятьПустыеСтроки = Ложь) Экспорт
	Если ТипЗнч(Разделители) = Тип("Массив") ИЛИ ТипЗнч(Разделители) = Тип("ФиксированныйМассив") Тогда
		МассивРазделителей = Разделители;
	ИначеЕсли ТипЗнч(Разделители) = Тип("Строка") Тогда
		МассивРазделителей = Новый Массив;
		МассивРазделителей.Добавить(Разделители);
	ИначеЕсли ТипЗнч(Разделители) = Тип("Структура") ИЛИ ТипЗнч(Разделители) = Тип("Соответствие") ИЛИ ТипЗнч(Разделители) = Тип("ФиксированнаяСтруктура") ИЛИ ТипЗнч(Разделители) = Тип("ФиксированноеСоответствие") ИЛИ ТипЗнч(Разделители) = Тип("СписокЗначений") Тогда
		МассивРазделителей = Новый Массив;
		Для каждого ЭлементРазделители Из Разделители Цикл
			МассивРазделителей.Добавить(ЭлементРазделители.Значение);
		КонецЦикла;
	КонецЕсли;
	Для каждого Разделитель Из МассивРазделителей Цикл
		СтрокаТекста=СтрЗаменить(СтрокаТекста, Разделитель, Символы.ПС);
	КонецЦикла; 
	МассивСтрок = Новый Массив;
	Для НомерСтроки = 1 По СтрЧислоСтрок(СтрокаТекста) Цикл
		ОчереднаяСтрока = СтрПолучитьСтроку(СтрокаТекста, НомерСтроки);
		Если ЗначениеЗаполнено(ОчереднаяСтрока) ИЛИ ОставлятьПустыеСтроки Тогда
			МассивСтрок.Добавить(СокрЛП(ОчереднаяСтрока));
		КонецЕсли;
	КонецЦикла;
	ВозВрат МассивСтрок;
КонецФункции

// БоР : Функция проверяет наличие в строке только цифр 28.09.2008 18:16:27
Функция ЕстьНеЦифры(Знач СтрокаПроверки) Экспорт

	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Истина;
	КонецЕсли;
	
	СтрокаПроверки = СокрЛП(СтрокаПроверки);
	Длина = СтрДлина(СтрокаПроверки);
	
	Для а = 1 По Длина Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если (КодСимвола < 48) ИЛИ (КодСимвола > 57) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
	
КонецФункции

Функция РазобратьСтрокуФИО(ФИО) Экспорт
	
	СтруктураФИО = Новый Структура;
	СтруктураФИО.Вставить("Фамилия"		, "");
	СтруктураФИО.Вставить("Имя"			, "");
	СтруктураФИО.Вставить("Отчество"	, "");
	
	СписокРазделителей = Новый СписокЗначений;
	СписокРазделителей.Добавить(" ");
	СписокРазделителей.Добавить(".");
	СписокРазделителей.Добавить(",");
	СловаСтроки = БоР_ОбщийМодульКлиентСервер.РазобратьСтрокуНаСлова(ФИО, СписокРазделителей);
	Если Ложь Тогда
		СловаСтроки = Новый СписокЗначений;
	КонецЕсли;
	Если СловаСтроки.Количество() = 0 Тогда
		ВозВрат СтруктураФИО;
	КонецЕсли;
	Если СловаСтроки.Количество() > 0 Тогда
		СтруктураФИО.Фамилия		= СокрЛП(СловаСтроки[0].Значение);
	КонецЕсли;
	Если СловаСтроки.Количество() > 1 Тогда
		СтруктураФИО.Имя			= СокрЛП(СловаСтроки[1].Значение);
	КонецЕсли;
	Если СловаСтроки.Количество() > 2 Тогда
		СтруктураФИО.Отчество		= СокрЛП(СловаСтроки[2].Значение);
	КонецЕсли;
	
	ВозВрат СтруктураФИО;
КонецФункции

// Разбирает строку URI на составные части и возвращает в виде структуры.
// На основе RFC 3986.
//
// Параметры:
//  СтрокаURI - Строка - ссылка на ресурс в формате:
//    
//     <схема>://<логин>:<пароль>@<хост>:<порт>/<путь>?<параметры>#<якорь>
//               \______________/ \___________/
//                      |               |
//           	   авторизация     имя сервера
//               \____________________________/ \________________________/
//                              |                            |
//                       строка соединения            путь на сервере
//
// Возвращаемое значение:
//  Структура:
//             Схема         - Строка;
//             Логин         - Строка; 
//             Пароль        - Строка;
//             ИмяСервера    - Строка;
//             Хост          - Строка; 
//             Порт          - Строка; 
//             ПутьНаСервере - Строка;
//
Функция РазобратьURI(Знач СтрокаURI) Экспорт
    ////////////////////////////////////////////////////////////////////////////////////////
	// БоР : Взято из БСП и переделано 03.12.2013 20:59:56
	
	СтрокаURI = СокрЛП(СтрокаURI);
	СтрокаURI = СтрЗаменить(СтрокаURI, "\\", "//");
	
	// схема
	Схема = "";
	Позиция = Найти(СтрокаURI, "://");
	Если Позиция > 0 Тогда
		Схема = НРег(Лев(СтрокаURI, Позиция - 1));
		СтрокаURI = Сред(СтрокаURI, Позиция + 3);
	КонецЕсли;

	// строка соединения и путь на сервере
	СтрокаСоединения = СтрокаURI;
	ПутьНаСервере = "";
	Позиция = Найти(СтрокаСоединения, "/");
	Если Позиция > 0 Тогда
		ПутьНаСервере = Сред(СтрокаСоединения, Позиция + 1);
		СтрокаСоединения = Лев(СтрокаСоединения, Позиция - 1);
	КонецЕсли;
		
	// информация пользователя и имя сервера
	СтрокаАвторизации = "";
	ИмяСервера = СтрокаСоединения;
	Позиция = Найти(СтрокаСоединения, "@");
	Если Позиция > 0 Тогда
		СтрокаАвторизации = Лев(СтрокаСоединения, Позиция - 1);
		ИмяСервера = Сред(СтрокаСоединения, Позиция + 1);
	КонецЕсли;
	
	// логин и пароль
	Логин = СтрокаАвторизации;
	Пароль = "";
	Позиция = Найти(СтрокаАвторизации, ":");
	Если Позиция > 0 Тогда
		Логин = Лев(СтрокаАвторизации, Позиция - 1);
		Пароль = Сред(СтрокаАвторизации, Позиция + 1);
	КонецЕсли;
	
	// хост и порт
	Хост = ИмяСервера;
	Порт = "";
	Позиция = Найти(ИмяСервера, ":");
	Если Позиция > 0 Тогда
		Хост = Лев(ИмяСервера, Позиция - 1);
		Порт = Сред(ИмяСервера, Позиция + 1);
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("Схема", Схема);
	Результат.Вставить("Логин", Логин);
	Результат.Вставить("Пароль", Пароль);
	Результат.Вставить("ИмяСервера", ИмяСервера);
	Результат.Вставить("Хост", Хост);
	Результат.Вставить("Порт", Порт);
	Результат.Вставить("ПутьНаСервере", ПутьНаСервере);
	
	Возврат Результат;
	
КонецФункции
 
// БоР : Функция проверяет наличие в строке только цифр 28.09.2008 18:16:27
Функция ОставитьТолькоЦифры(Знач СтрокаСимволов) Экспорт

	СтрокаСимволов = СокрЛП(СтрокаСимволов);
	СтрокаЦифр = "";

	Длина = СтрДлина(СтрокаСимволов);
	
	Для НомерСимвола = 1 По Длина Цикл
		ОчереднойСимвол = Сред(СтрокаСимволов, НомерСимвола, 1);
		КодСимвола = КодСимвола(ОчереднойСимвол);
		Если (КодСимвола >= 48) И (КодСимвола <= 57) Тогда
			СтрокаЦифр = СтрокаЦифр + ОчереднойСимвол;
		КонецЕсли;
	КонецЦикла;
	Возврат СтрокаЦифр;
	
КонецФункции

#КонецОбласти

#Область Единицы_прописью
// БоР : Возвращает единицу измерения, другой предмет исчисления в нужном падеже 07.10.2010 22:11:19
Функция ЕдиницаПрописью(Знач Количество, Знач ФорматнаяСтрока) Экспорт
	// Напрмиер Количество = 10 - ответ - листов
	// 			Количество = 3  - ответ - листа
	// ФорматнаяСтрока например : "листа, листов, листов, м, , , , ,0"
	ВозВрат СтрЗаменить(ЧислоПрописью(ВЧисло(Количество), "НП=Истина, НД=Ложь", ФорматнаяСтрока),
						ЧислоПрописью(ВЧисло(Количество), "НП=Ложь  , НД=Ложь", " , , , , , , , ,0"),
	                    "");
КонецФункции
 
// БоР : Возвращает единицу измерения, другой предмет исчисления в нужном падеже 07.10.2010 22:11:19
Функция РублиПрописью(Знач Сумма) Экспорт
	ВозВрат ЧислоПрописью(ВЧисло(Сумма), "НП=Истина, НД=Ложь", "рубль, рубля, рублей, м, копейка, копейки, копеек, ж, 2");
КонецФункции
#КонецОбласти

#Область Телефонные_номера

// БоР :  04.03.2014 21:23:41
Функция ПривестиТелефонныйНомерКСтандартномуВиду(Знач НомерТелефона, НестандартныйНомер = Неопределено, ФедеральныйНомер = Неопределено) Экспорт
	
	НестандартныйНомер		= Истина;
	ФедеральныйНомер		= Ложь;
		
	НомерТелефона = СокрЛП(НомерТелефона);
	Если Не ЗначениеЗаполнено(НомерТелефона) Тогда
		ВозВрат НомерТелефона; 
	КонецЕсли;
	НомерТелефона = ОставитьТолькоЦифры(НомерТелефона);
	
	Если СтрДлина(НомерТелефона) = 11 Тогда // Федеральный номер с семеркой - 11 цифр
		Если Лев(НомерТелефона, 1) = "7" Тогда
			НомерТелефона = Сред(НомерТелефона, 2);
		КонецЕсли;
		Если Лев(НомерТелефона, 1) = "8" Тогда
			НомерТелефона = Сред(НомерТелефона, 2);
		КонецЕсли;
		КодГорода		= Сред(НомерТелефона, 1, 3);
		Часть1			= Сред(НомерТелефона, 4, 3);
		Часть2			= Сред(НомерТелефона, 7, 2);
		Часть3			= Сред(НомерТелефона, 9, 2);
		НомерТелефона	= "+7 " + КодГорода + " " + Часть1 + " " + Часть2 + " " + Часть3;
		НомерТелефона	= "7" + КодГорода + "" + Часть1 + "" + Часть2 + "" + Часть3;
		НестандартныйНомер		= Ложь;
		ФедеральныйНомер		= Истина;
	ИначеЕсли СтрДлина(НомерТелефона) = 10 Тогда // Федеральный номер - 10 цифр
		КодГорода		= Сред(НомерТелефона, 1, 3);
		Часть1			= Сред(НомерТелефона, 4, 3);
		Часть2			= Сред(НомерТелефона, 7, 2);
		Часть3			= Сред(НомерТелефона, 9, 2);
		НомерТелефона	= "+7 " + КодГорода + " " + Часть1 + " " + Часть2 + " " + Часть3;
		НомерТелефона	= "7" + КодГорода + "" + Часть1 + "" + Часть2 + "" + Часть3;
		НестандартныйНомер		= Ложь;
		ФедеральныйНомер		= Истина;
	ИначеЕсли СтрДлина(НомерТелефона) = 7 Тогда // считаем, что Городской номер в НСК - 7 цифр (+7383XXXXXXX)/ Другие города не учитываем - иначе сложно
		КодГорода		= "383";
		Часть1			= Сред(НомерТелефона, 1, 3);
		Часть2			= Сред(НомерТелефона, 4, 2);
		Часть3			= Сред(НомерТелефона, 6, 2);
		НомерТелефона	= "+7 " + КодГорода + " " + Часть1 + " " + Часть2 + " " + Часть3;
		НомерТелефона	= "7" + КодГорода + "" + Часть1 + "" + Часть2 + "" + Часть3;
		НестандартныйНомер		= Ложь;
		ФедеральныйНомер		= Ложь;
	Иначе // не распознается - ничего не поделаешь
		НомерТелефона	= НомерТелефона;
		НестандартныйНомер		= Истина;
		ФедеральныйНомер		= Ложь;
	КонецЕсли;
	
	ВозВрат НомерТелефона;
	
КонецФункции

// БоР :  04.03.2014 23:01:42
Функция ИзвлечьНомераИзСтроки(Знач СтрокаНомеров) Экспорт
	
	МассивНомеров = Новый Массив;
	
	СписокРазделителей = Новый СписокЗначений;
	СписокРазделителей.Добавить(",");
	СписокРазделителей.Добавить(";");
	СписокРазделителей.Добавить("\");
	СписокРазделителей.Добавить("/");
	СписокРазделителей.Добавить("или");
	СписокРазделителей.Добавить("и");
	СписокСлов = РазобратьСтрокуНаСлова(СтрокаНомеров, СписокРазделителей, Ложь);
	
	Для каждого Слово Из СписокСлов Цикл
		НомерТелефона = Слово.Значение;
		НомерТелефона = ПривестиТелефонныйНомерКСтандартномуВиду(НомерТелефона);
		Если ЗначениеЗаполнено(НомерТелефона) Тогда
			МассивНомеров.Добавить(НомерТелефона);
		КонецЕсли;
	КонецЦикла;
	
	ВозВрат МассивНомеров;
	
КонецФункции

#КонецОбласти

#Область ФорматированныйДокумент
// БоР : извлечение из ТекстXML ранее сложенного туда объекта ФорматированныйДокумент и попутное формирование HTML - документа, без потери картинок 24.08.2017 16:34:32
Функция РазвернутьФорматированныйДокументИзXML(ТекстXML, ФорматированныйДокумент = Неопределено, ТекстHTML = -1, Текст = -1, ПоместитьКартинкиВоВременноеХранилище = Ложь, Знач УникальныйИдентификаторДляХранилища = Неопределено) Экспорт
	//Если ПоместитьКартинкиВоВременноеХранилище И УникальныйИдентификаторДляХранилища = Неопределено Тогда
	//	УникальныйИдентификаторДляХранилища = Новый УникальныйИдентификатор;
	//КонецЕсли;
	ФорматированныйДокумент = БоР_ОбщийМодуль.ЗначениеИзXML(ТекстXML);
	Если ТипЗнч(ФорматированныйДокумент) <> Тип("ФорматированныйДокумент") Тогда
		ФорматированныйДокумент = Новый ФорматированныйДокумент;
	КонецЕсли;
	Если Текст <> -1 Тогда // "-1" - маркер, что параметр не указан. Неопределено может быть в неинициализированной переменной. А "-1" - менее вероятно
		Текст = ФорматированныйДокумент.ПолучитьТекст();
	КонецЕсли;
	Если ТекстHTML <> -1 Тогда // "-1" - маркер, что параметр не указан. Неопределено может быть в неинициализированной переменной. А "-1" - менее вероятно
		СтруктураКартинок = Новый Структура;
		ФорматированныйДокумент.ПолучитьHTML(ТекстHTML, СтруктураКартинок);
		Для Каждого Картинка Из СтруктураКартинок Цикл
			Если ПоместитьКартинкиВоВременноеХранилище Тогда
				АдресКартинки = ПоместитьВоВременноеХранилище(Картинка.Значение, УникальныйИдентификаторДляХранилища);
				ТекстHTML = СтрЗаменить(ТекстHTML, Картинка.Ключ, АдресКартинки);
			Иначе
				ТекстHTML = СтрЗаменить(ТекстHTML, Картинка.Ключ, "data:image/" + Картинка.Значение.Формат() + ";base64," + Base64Строка(Картинка.Значение.ПолучитьДвоичныеДанные()));
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
КонецФункции

// БоР : конвертирование ФД в XML и другие форматы 24.08.2017 16:34:32
Функция ЗавернутьФорматированныйДокументВ_XML(ФорматированныйДокумент, ТекстXML = -1, ТекстHTML = -1, Текст = -1, ПоместитьКартинкиВоВременноеХранилище = Ложь, Знач УникальныйИдентификаторДляХранилища = Неопределено) Экспорт
	
	Если ТипЗнч(ФорматированныйДокумент) <> Тип("ФорматированныйДокумент") Тогда
		ФорматированныйДокумент = Новый ФорматированныйДокумент;
	КонецЕсли;
	Если ТекстXML <> -1 Тогда // "-1" - маркер, что параметр не указан. Неопределено может быть в неинициализированной переменной. А "-1" - менее вероятно
		ТекстXML = БоР_ОбщийМодуль.ЗначениеВXML(ФорматированныйДокумент);
	КонецЕсли;
	Если Текст <> -1 Тогда // "-1" - маркер, что параметр не указан. Неопределено может быть в неинициализированной переменной. А "-1" - менее вероятно
		Текст = ФорматированныйДокумент.ПолучитьТекст();
	КонецЕсли;
	Если ТекстHTML <> -1 Тогда // "-1" - маркер, что параметр не указан. Неопределено может быть в неинициализированной переменной. А "-1" - менее вероятно
		СтруктураКартинок = Новый Структура;
		ФорматированныйДокумент.ПолучитьHTML(ТекстHTML, СтруктураКартинок);
		Для Каждого Картинка Из СтруктураКартинок Цикл
			Если ПоместитьКартинкиВоВременноеХранилище Тогда
				АдресКартинки = ПоместитьВоВременноеХранилище(Картинка.Значение, УникальныйИдентификаторДляХранилища);
				ТекстHTML = СтрЗаменить(ТекстHTML, Картинка.Ключ, АдресКартинки);
			Иначе
				ТекстHTML = СтрЗаменить(ТекстHTML, Картинка.Ключ, "data:image/" + Картинка.Значение.Формат() + ";base64," + Base64Строка(Картинка.Значение.ПолучитьДвоичныеДанные()));
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
КонецФункции
#КонецОбласти

// БоР : Универсальные и почти универсальные процедуры 25.06.2015 15:35:49
// БоР : Есть также блоки, требующие определенных метаданных, но достаточно общие для многих конфигураций  25.06.2015 15:35:49
////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////
// БоР : Процедуры, имеющие отношение к "универсальным" подсистемам и механизмам (типа БСП). Или очень часто встречающиеся 25.06.2015 15:40:28

// БоР : Процедуры, имеющиеотношение к "универсальным" подсистемам и механизмам (типа БСП) 25.06.2015 15:40:28
////////////////////////////////////////////////////////////////////////////////////////

#Область Процедуры_этой_конфигурации
////////////////////////////////////////////////////////////////////////////////////////
// БоР : Процедуры, специфичные для этой конфигурации 17.07.2017 2:45:28

Процедура УРВ_ДатаВремяНачалаПриИзменении(ДатаВремяНачала, ДатаВремяОкончания, Продолжительность, Поле = "", ПутьКДанным = "", КлючДанных = Неопределено, БазоваяДата = Неопределено, СкорректироватьПоШкале = Истина) Экспорт
	СекундОтНачалаДня = ДатаВремяНачала - НачалоДня(ДатаВремяНачала);
	Если БазоваяДата = Неопределено Тогда
		БазоваяДата = НачалоДня(ДатаВремяНачала);
	ИначеЕсли НачалоДня(ДатаВремяНачала) <> НачалоДня(БазоваяДата) Тогда
		БазоваяДата = НачалоДня(БазоваяДата);
		ДатаВремяНачала = БазоваяДата + СекундОтНачалаДня;
	КонецЕсли;
	Если СкорректироватьПоШкале Тогда
		ШагСеткиМин = Бор_ПовторноеИспользованиеКлиентСервер.ПолучитьШагСеткиРасписания();
		ШагСеткиСек = ШагСеткиМин * 60;
		ОстатокОтДеления = СекундОтНачалаДня % ШагСеткиСек;
		Если ОстатокОтДеления <> 0 Тогда
			Сообщение = Новый СообщениеПользователю;
			Сообщение.Текст = "Время должно быть кратно " + ШагСеткиМин + " минутам!";
			Сообщение.Поле = Поле;
			Сообщение.КлючДанных = КлючДанных;
			Сообщение.ПутьКДанным = ПутьКДанным;
			Сообщение.Сообщить();
			СекундОтНачалаДня = Макс(Окр(СекундОтНачалаДня/ШагСеткиСек)*ШагСеткиСек, ШагСеткиСек);
			ДатаВремяНачала = НачалоДня(БазоваяДата) + СекундОтНачалаДня;
		КонецЕсли;
	КонецЕсли;
	ДатаВремяОкончания = ДатаВремяНачала + Продолжительность * 60;
КонецПроцедуры

Процедура УРВ_БазоваяДатаПриИзменении(ДатаВремяНачала, ДатаВремяОкончания, БазоваяДата) Экспорт
	СекундОтНачалаДня = ДатаВремяНачала - НачалоДня(ДатаВремяНачала);
	ДатаВремяНачала = БазоваяДата + СекундОтНачалаДня;
	СекундОтНачалаДня = ДатаВремяОкончания - НачалоДня(ДатаВремяОкончания);
	ДатаВремяОкончания = БазоваяДата + СекундОтНачалаДня;
КонецПроцедуры

Процедура УРВ_ДатаВремяОкончанияПриИзменении(ДатаВремяНачала, ДатаВремяОкончания, Продолжительность, Поле = "", ПутьКДанным = "", КлючДанных = Неопределено, СкорректироватьПоШкале = Истина) Экспорт
	БазоваяДата = НачалоДня(ДатаВремяНачала);
	СекундОтНачалаДня = ДатаВремяОкончания - НачалоДня(ДатаВремяОкончания);
	ДатаВремяОкончания = БазоваяДата + СекундОтНачалаДня;
	ДатаВремяОкончания = Макс(ДатаВремяНачала, ДатаВремяОкончания);
	СекундОтНачалаДня = ДатаВремяОкончания - НачалоДня(ДатаВремяОкончания);
	Если СкорректироватьПоШкале Тогда
		ШагСеткиМин = Бор_ПовторноеИспользованиеКлиентСервер.ПолучитьШагСеткиРасписания();
		ШагСеткиСек = ШагСеткиМин * 60;
		ОстатокОтДеления = СекундОтНачалаДня % ШагСеткиСек;
		Если ОстатокОтДеления <> 0 Тогда
			Сообщение = Новый СообщениеПользователю;
			Сообщение.Текст = "Время должно быть кратно " + ШагСеткиМин + " минутам!";
			Сообщение.Поле = Поле;
			Сообщение.КлючДанных = КлючДанных;
			Сообщение.ПутьКДанным = ПутьКДанным;
			Сообщение.Сообщить();
			СекундОтНачалаДня = Макс(Окр(СекундОтНачалаДня/ШагСеткиСек)*ШагСеткиСек, ШагСеткиСек);
			ДатаВремяОкончания = БазоваяДата + СекундОтНачалаДня;
		КонецЕсли;
	КонецЕсли;
	Продолжительность = (ДатаВремяОкончания - ДатаВремяНачала)/60;
КонецПроцедуры

Процедура УРВ_ПродолжительностьПриИзменении(ДатаВремяНачала, ДатаВремяОкончания, Продолжительность, Поле = "", ПутьКДанным = "", КлючДанных = Неопределено, СкорректироватьПоШкале = Истина) Экспорт
	ШагСеткиМин = Бор_ПовторноеИспользованиеКлиентСервер.ПолучитьШагСеткиРасписания();
	ОстатокОтДеления = Продолжительность % ШагСеткиМин;
	Если СкорректироватьПоШкале Тогда
		Если ОстатокОтДеления <> 0 Тогда
			Сообщение = Новый СообщениеПользователю;
			Сообщение.Текст = "Продолжительность должна быть кратна " + ШагСеткиМин + " минутам!";
			Сообщение.Поле = Поле;
			Сообщение.КлючДанных = КлючДанных;
			Сообщение.ПутьКДанным = ПутьКДанным;
			Сообщение.Сообщить();
			Продолжительность = Макс(Окр(Продолжительность/ШагСеткиМин)*ШагСеткиМин, ШагСеткиМин);
		КонецЕсли;
	КонецЕсли;
	ДатаВремяОкончания = ДатаВремяНачала + Продолжительность * 60;
КонецПроцедуры

Процедура УРВ_СкорректироватьВремяПоШкале(ДатаВремя, Поле = "", ПутьКДанным = "", КлючДанных = Неопределено) Экспорт
	СекундОтНачалаДня = ДатаВремя - НачалоДня(ДатаВремя);
	ШагСеткиМин = Бор_ПовторноеИспользованиеКлиентСервер.ПолучитьШагСеткиРасписания();
	ШагСеткиСек = ШагСеткиМин * 60;
	ОстатокОтДеления = СекундОтНачалаДня % ШагСеткиСек;
	Если ОстатокОтДеления <> 0 Тогда
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст = "Время должно быть кратно " + ШагСеткиМин + " минутам!";
		Сообщение.Поле = Поле;
		Сообщение.КлючДанных = КлючДанных;
		Сообщение.ПутьКДанным = ПутьКДанным;
		Сообщение.Сообщить();
		СекундОтНачалаДня = Макс(Окр(СекундОтНачалаДня/ШагСеткиСек)*ШагСеткиСек, ШагСеткиСек);
		ДатаВремя = НачалоДня(ДатаВремя) + СекундОтНачалаДня;
	КонецЕсли;
КонецПроцедуры

Процедура УРВ_СкорректироватьПродолжительностьПоШкале(Продолжительность, Поле = "", ПутьКДанным = "", КлючДанных = Неопределено) Экспорт
	ШагСеткиМин = Бор_ПовторноеИспользованиеКлиентСервер.ПолучитьШагСеткиРасписания();
	ОстатокОтДеления = Продолжительность % ШагСеткиМин;
	Если ОстатокОтДеления <> 0 Тогда
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст = "Продолжительность должна быть кратна " + ШагСеткиМин + " минутам!";
		Сообщение.Поле = Поле;
		Сообщение.КлючДанных = КлючДанных;
		Сообщение.ПутьКДанным = ПутьКДанным;
		Сообщение.Сообщить();
		Продолжительность = Макс(Окр(Продолжительность/ШагСеткиМин)*ШагСеткиМин, ШагСеткиМин);
	КонецЕсли;
КонецПроцедуры

// БоР : Процедуры, специфичные для этой конфигурации 17.07.2017 2:45:28
////////////////////////////////////////////////////////////////////////////////////////
#КонецОбласти



